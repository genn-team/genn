<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pygenn package &mdash; PyGeNN  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="PyGeNN implementation of SuperSpike" href="../userproject/superspike_demo.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            PyGeNN
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../upgrading.html">Upgrading from GeNN 4</a></li>
<li class="toctree-l1"><a class="reference internal" href="../building_networks.html">Building networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../simulating_networks.html">Simulating networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../custom_models.html">Custom models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userproject/index.html">User projects</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Reference documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyGeNN</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">pygenn package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/source/pygenn.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pygenn">
<span id="pygenn-package"></span><h1>pygenn package<a class="headerlink" href="#module-pygenn" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="pygenn.CurrentSource">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">CurrentSource</span></span><a class="headerlink" href="#pygenn.CurrentSource" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code>, <a class="reference internal" href="#pygenn.genn_groups.CurrentSourceMixin" title="pygenn.genn_groups.CurrentSourceMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">CurrentSourceMixin</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CurrentSource.get_var_location">
<span class="sig-name descname"><span class="pre">get_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CurrentSource" title="pygenn._genn.CurrentSource"><span class="pre">pygenn._genn.CurrentSource</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></span><a class="headerlink" href="#pygenn.CurrentSource.get_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Get variable location for current source model state variable</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CurrentSource.model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#pygenn.CurrentSource.model" title="Permalink to this definition"></a></dt>
<dd><p>Current source model used for this source</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CurrentSource.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.CurrentSource.name" title="Permalink to this definition"></a></dt>
<dd><p>Unique name of current source</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CurrentSource.params">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">params</span></span><a class="headerlink" href="#pygenn.CurrentSource.params" title="Permalink to this definition"></a></dt>
<dd><p>Values of current source parameters</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CurrentSource.set_param_dynamic">
<span class="sig-name descname"><span class="pre">set_param_dynamic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CurrentSource" title="pygenn._genn.CurrentSource"><span class="pre">pygenn._genn.CurrentSource</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.CurrentSource.set_param_dynamic" title="Permalink to this definition"></a></dt>
<dd><p>Set whether parameter is dynamic or not i.e. it can be changed at runtime</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CurrentSource.set_var_location">
<span class="sig-name descname"><span class="pre">set_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CurrentSource" title="pygenn._genn.CurrentSource"><span class="pre">pygenn._genn.CurrentSource</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.CurrentSource.set_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Set location of current source state variable.
This is ignored for simulations on hardware with a single memory space.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">CustomConnectivityUpdate</span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code>, <a class="reference internal" href="#pygenn.genn_groups.CustomConnectivityUpdateMixin" title="pygenn.genn_groups.CustomConnectivityUpdateMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">CustomConnectivityUpdateMixin</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.get_post_var_location">
<span class="sig-name descname"><span class="pre">get_post_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CustomConnectivityUpdate" title="pygenn._genn.CustomConnectivityUpdate"><span class="pre">pygenn._genn.CustomConnectivityUpdate</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.get_post_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Get variable location for postsynaptic state variable</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.get_pre_var_location">
<span class="sig-name descname"><span class="pre">get_pre_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CustomConnectivityUpdate" title="pygenn._genn.CustomConnectivityUpdate"><span class="pre">pygenn._genn.CustomConnectivityUpdate</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.get_pre_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Get variable location for presynaptic state variable</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.get_var_location">
<span class="sig-name descname"><span class="pre">get_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CustomConnectivityUpdate" title="pygenn._genn.CustomConnectivityUpdate"><span class="pre">pygenn._genn.CustomConnectivityUpdate</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.get_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Get variable location for synaptic state variable</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.model" title="Permalink to this definition"></a></dt>
<dd><p>Custom connectivity update model used for this update</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.name" title="Permalink to this definition"></a></dt>
<dd><p>Unique name of custom connectivity update</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.params">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">params</span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.params" title="Permalink to this definition"></a></dt>
<dd><p>Values of custom connectivity update parameters</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.set_param_dynamic">
<span class="sig-name descname"><span class="pre">set_param_dynamic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CustomConnectivityUpdate" title="pygenn._genn.CustomConnectivityUpdate"><span class="pre">pygenn._genn.CustomConnectivityUpdate</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.set_param_dynamic" title="Permalink to this definition"></a></dt>
<dd><p>Set whether parameter is dynamic or not i.e. it can be changed at runtime</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.set_post_var_location">
<span class="sig-name descname"><span class="pre">set_post_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CustomConnectivityUpdate" title="pygenn._genn.CustomConnectivityUpdate"><span class="pre">pygenn._genn.CustomConnectivityUpdate</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.set_post_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Set location of postsynaptic state variable.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.set_pre_var_location">
<span class="sig-name descname"><span class="pre">set_pre_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CustomConnectivityUpdate" title="pygenn._genn.CustomConnectivityUpdate"><span class="pre">pygenn._genn.CustomConnectivityUpdate</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.set_pre_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Set location of presynaptic state variable.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.set_var_location">
<span class="sig-name descname"><span class="pre">set_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CustomConnectivityUpdate" title="pygenn._genn.CustomConnectivityUpdate"><span class="pre">pygenn._genn.CustomConnectivityUpdate</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.set_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Set location of synaptic state variable.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.synapse_group">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">synapse_group</span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.synapse_group" title="Permalink to this definition"></a></dt>
<dd><p>Synapse group this custom connectivity update is associated with</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomConnectivityUpdate.update_group_name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_group_name</span></span><a class="headerlink" href="#pygenn.CustomConnectivityUpdate.update_group_name" title="Permalink to this definition"></a></dt>
<dd><p>Name of the update group this custom connectivity update is part of</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.CustomUpdate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">CustomUpdate</span></span><a class="headerlink" href="#pygenn.CustomUpdate" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.CustomUpdateBase" title="pygenn._genn.CustomUpdateBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">CustomUpdateBase</span></code></a>, <a class="reference internal" href="#pygenn.genn_groups.CustomUpdateMixin" title="pygenn.genn_groups.CustomUpdateMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">CustomUpdateMixin</span></code></a></p>
<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomUpdate.num_neurons">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_neurons</span></span><a class="headerlink" href="#pygenn.CustomUpdate.num_neurons" title="Permalink to this definition"></a></dt>
<dd><p>Number of neurons custom update operates over.
This must be the same for all groups whose variables are referenced</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.CustomUpdateBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">CustomUpdateBase</span></span><a class="headerlink" href="#pygenn.CustomUpdateBase" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CustomUpdateBase.get_var_location">
<span class="sig-name descname"><span class="pre">get_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CustomUpdateBase" title="pygenn._genn.CustomUpdateBase"><span class="pre">pygenn._genn.CustomUpdateBase</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></span><a class="headerlink" href="#pygenn.CustomUpdateBase.get_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Get variable location for custom update model state variable</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomUpdateBase.model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#pygenn.CustomUpdateBase.model" title="Permalink to this definition"></a></dt>
<dd><p>Custom update model used for this update</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomUpdateBase.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.CustomUpdateBase.name" title="Permalink to this definition"></a></dt>
<dd><p>Unique name of custom update</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomUpdateBase.params">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">params</span></span><a class="headerlink" href="#pygenn.CustomUpdateBase.params" title="Permalink to this definition"></a></dt>
<dd><p>Values of custom connectivity update parameters</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CustomUpdateBase.set_param_dynamic">
<span class="sig-name descname"><span class="pre">set_param_dynamic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CustomUpdateBase" title="pygenn._genn.CustomUpdateBase"><span class="pre">pygenn._genn.CustomUpdateBase</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.CustomUpdateBase.set_param_dynamic" title="Permalink to this definition"></a></dt>
<dd><p>Set whether parameter is dynamic or not i.e. it can be changed at runtime</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.CustomUpdateBase.set_var_location">
<span class="sig-name descname"><span class="pre">set_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CustomUpdateBase" title="pygenn._genn.CustomUpdateBase"><span class="pre">pygenn._genn.CustomUpdateBase</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.CustomUpdateBase.set_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Set location of state variable.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomUpdateBase.update_group_name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_group_name</span></span><a class="headerlink" href="#pygenn.CustomUpdateBase.update_group_name" title="Permalink to this definition"></a></dt>
<dd><p>Name of the update group this custom connectivity update is part of</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.CustomUpdateVarAccess">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">CustomUpdateVarAccess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.CustomUpdateVarAccess" title="pygenn._genn.CustomUpdateVarAccess"><span class="pre">pygenn._genn.CustomUpdateVarAccess</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.CustomUpdateVarAccess" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Supported combinations of access mode and dimension for custom update variables.
The axes are defined ‘subtractively’, i.e. VarAccessDim::BATCH indicates that this axis should be removed.</p>
<p>Members:</p>
<blockquote>
<div><p>READ_WRITE : This variable can be read from and written to and has the same dimensions as whatever the custom update is attached to</p>
<p>READ_ONLY : This variable can only be read from and has the same dimensions as whatever the custom update is attached to</p>
<p>READ_ONLY_SHARED : This variable can only be read from and has the same dimensions as whatever</p>
</div></blockquote>
<p>the custom update is attached to aside from being shared across batches</p>
<blockquote>
<div><p>READ_ONLY_SHARED_NEURON : This variable can only be read from and has the same dimensions as whatever</p>
</div></blockquote>
<p>the custom update is attached to aside from being shared across neurons</p>
<blockquote>
<div><p>REDUCE_BATCH_SUM : This variable is a target for a reduction across batches using a sum operation</p>
<p>REDUCE_BATCH_MAX : This variable is a target for a reduction across batches using a max operation</p>
<p>REDUCE_NEURON_SUM : This variable is a target for a reduction across neurons using a sum operation</p>
<p>REDUCE_NEURON_MAX : This variable is a target for a reduction across neurons using a max operation</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.CustomUpdateVarAccess.READ_ONLY">
<span class="sig-name descname"><span class="pre">READ_ONLY</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CustomUpdateVarAccess.READ_ONLY:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pygenn.CustomUpdateVarAccess.READ_ONLY" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.CustomUpdateVarAccess.READ_ONLY_SHARED">
<span class="sig-name descname"><span class="pre">READ_ONLY_SHARED</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CustomUpdateVarAccess.READ_ONLY_SHARED:</span> <span class="pre">65&gt;</span></em><a class="headerlink" href="#pygenn.CustomUpdateVarAccess.READ_ONLY_SHARED" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.CustomUpdateVarAccess.READ_ONLY_SHARED_NEURON">
<span class="sig-name descname"><span class="pre">READ_ONLY_SHARED_NEURON</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CustomUpdateVarAccess.READ_ONLY_SHARED_NEURON:</span> <span class="pre">33&gt;</span></em><a class="headerlink" href="#pygenn.CustomUpdateVarAccess.READ_ONLY_SHARED_NEURON" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.CustomUpdateVarAccess.READ_WRITE">
<span class="sig-name descname"><span class="pre">READ_WRITE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CustomUpdateVarAccess.READ_WRITE:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pygenn.CustomUpdateVarAccess.READ_WRITE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.CustomUpdateVarAccess.REDUCE_BATCH_MAX">
<span class="sig-name descname"><span class="pre">REDUCE_BATCH_MAX</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CustomUpdateVarAccess.REDUCE_BATCH_MAX:</span> <span class="pre">84&gt;</span></em><a class="headerlink" href="#pygenn.CustomUpdateVarAccess.REDUCE_BATCH_MAX" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.CustomUpdateVarAccess.REDUCE_BATCH_SUM">
<span class="sig-name descname"><span class="pre">REDUCE_BATCH_SUM</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CustomUpdateVarAccess.REDUCE_BATCH_SUM:</span> <span class="pre">76&gt;</span></em><a class="headerlink" href="#pygenn.CustomUpdateVarAccess.REDUCE_BATCH_SUM" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.CustomUpdateVarAccess.REDUCE_NEURON_MAX">
<span class="sig-name descname"><span class="pre">REDUCE_NEURON_MAX</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CustomUpdateVarAccess.REDUCE_NEURON_MAX:</span> <span class="pre">52&gt;</span></em><a class="headerlink" href="#pygenn.CustomUpdateVarAccess.REDUCE_NEURON_MAX" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.CustomUpdateVarAccess.REDUCE_NEURON_SUM">
<span class="sig-name descname"><span class="pre">REDUCE_NEURON_SUM</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;CustomUpdateVarAccess.REDUCE_NEURON_SUM:</span> <span class="pre">44&gt;</span></em><a class="headerlink" href="#pygenn.CustomUpdateVarAccess.REDUCE_NEURON_SUM" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomUpdateVarAccess.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.CustomUpdateVarAccess.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomUpdateVarAccess.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.CustomUpdateVarAccess.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.CustomUpdateWU">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">CustomUpdateWU</span></span><a class="headerlink" href="#pygenn.CustomUpdateWU" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.CustomUpdateBase" title="pygenn._genn.CustomUpdateBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">CustomUpdateBase</span></code></a>, <a class="reference internal" href="#pygenn.genn_groups.CustomUpdateWUMixin" title="pygenn.genn_groups.CustomUpdateWUMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">CustomUpdateWUMixin</span></code></a></p>
<dl class="py property">
<dt class="sig sig-object py" id="pygenn.CustomUpdateWU.synapse_group">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">synapse_group</span></span><a class="headerlink" href="#pygenn.CustomUpdateWU.synapse_group" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.GeNNModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">GeNNModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.ModelSpec" title="pygenn._genn.ModelSpec"><span class="pre">pygenn._genn.ModelSpec</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.ModelSpec" title="pygenn._genn.ModelSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelSpec</span></code></a></p>
<p>This class provides an interface for
defining, building and running models</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>precision</strong> (<em>str</em><em> | </em><em>ResolvedType</em>) – Data type to use for <code class="docutils literal notranslate"><span class="pre">scalar</span></code> variables</p></li>
<li><p><strong>model_name</strong> (<em>str</em>) – Name of the model</p></li>
<li><p><strong>backend</strong> (<em>str</em><em> | </em><em>None</em>) – Name of backend module to use. Currently
supported “single_threaded_cpu”, “cuda”.
Defaults to automatically picking the ‘best’
backend for your system</p></li>
<li><p><strong>time_precision</strong> (<em>str</em><em> | </em><em>ResolvedType</em><em> | </em><em>None</em>) – data type to use for representing time</p></li>
<li><p><strong>genn_log_level</strong> (<a class="reference internal" href="#pygenn.PlogSeverity" title="pygenn._genn.PlogSeverity"><em>PlogSeverity</em></a>) – Log level for GeNN</p></li>
<li><p><strong>code_gen_log_level</strong> (<a class="reference internal" href="#pygenn.PlogSeverity" title="pygenn._genn.PlogSeverity"><em>PlogSeverity</em></a>) – Log level for GeNN code-generator</p></li>
<li><p><strong>transpiler_log_level</strong> (<a class="reference internal" href="#pygenn.PlogSeverity" title="pygenn._genn.PlogSeverity"><em>PlogSeverity</em></a>) – Log level for GeNN transpiler</p></li>
<li><p><strong>runtime_log_level</strong> (<a class="reference internal" href="#pygenn.PlogSeverity" title="pygenn._genn.PlogSeverity"><em>PlogSeverity</em></a>) – Log level for GeNN runtime</p></li>
<li><p><strong>backend_log_level</strong> (<a class="reference internal" href="#pygenn.PlogSeverity" title="pygenn._genn.PlogSeverity"><em>PlogSeverity</em></a>) – Log level for backend</p></li>
<li><p><strong>preference_kwargs</strong> – Additional keyword arguments to set in backend preferences structure</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.add_current_source">
<span class="sig-name descname"><span class="pre">add_current_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cs_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_source_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.add_current_source" title="Permalink to this definition"></a></dt>
<dd><p>Add a current source to the GeNN model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cs_name</strong> (<em>str</em>) – unique name</p></li>
<li><p><strong>current_source_model</strong> (<em>CurrentSourceModelBase</em><em> | </em><em>str</em>) – current source model either as a string referencing a built-in model
(see <a class="reference internal" href="#module-pygenn.current_source_models" title="pygenn.current_source_models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">current_source_models</span></code></a>) or an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">CurrentSourceModelBase</span></code>
(for example returned by <a class="reference internal" href="#pygenn.create_current_source_model" title="pygenn.create_current_source_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_current_source_model()</span></code></a>)</p></li>
<li><p><strong>pop</strong> (<a class="reference internal" href="#pygenn.NeuronGroup" title="pygenn._genn.NeuronGroup"><em>NeuronGroup</em></a>) – neuron population to inject current into</p></li>
<li><p><strong>params</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>int</em><em> | </em><em>float</em><em>]</em>) – parameter values for the current source model (see <a class="reference internal" href="../building_networks.html#section-parameters"><span class="std std-ref">Parameters</span></a>)</p></li>
<li><p><strong>vars</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarInit</em><em> | </em><em>int</em><em> | </em><em>float</em><em> | </em><em>ndarray</em><em> | </em><em>Sequence</em><em>]</em>) – initial variable values or initialisers
for the current source model (see <a class="reference internal" href="../building_networks.html#section-variables"><span class="std std-ref">Variables</span></a>)</p></li>
<li><p><strong>var_refs</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarReference</em><em>]</em>) – variables references to neuron variables in <code class="docutils literal notranslate"><span class="pre">pop</span></code>,
typically created using <a class="reference internal" href="#pygenn.create_var_ref" title="pygenn.create_var_ref"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_var_ref()</span></code></a>
(see <a class="reference internal" href="../building_networks.html#section-variables-references"><span class="std std-ref">Variables references</span></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pygenn.CurrentSource" title="pygenn._genn.CurrentSource"><em>CurrentSource</em></a></p>
</dd>
</dl>
<p>For example, a current source to inject a Gaussian noise current can be added to a model as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">add_current_source</span><span class="p">(</span><span class="s2">&quot;noise&quot;</span><span class="p">,</span> <span class="s2">&quot;GaussianNoise&quot;</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span>
                              <span class="p">{</span><span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;sd&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">pop</span></code> is a reference to a neuron population
(as returned by <a class="reference internal" href="#pygenn.GeNNModel.add_neuron_population" title="pygenn.GeNNModel.add_neuron_population"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.add_neuron_population()</span></code></a>)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.add_custom_connectivity_update">
<span class="sig-name descname"><span class="pre">add_custom_connectivity_update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cu_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">syn_group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_conn_update_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egp_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.add_custom_connectivity_update" title="Permalink to this definition"></a></dt>
<dd><p>Add a custom connectivity update to the GeNN model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cu_name</strong> (<em>str</em>) – unique name</p></li>
<li><p><strong>group_name</strong> (<em>str</em>) – name of the ‘custom update group’ to include this update in.
All custom updates in the same group are executed simultaneously.</p></li>
<li><p><strong>syn_group</strong> (<a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><em>SynapseGroup</em></a>) – Synapse group to attach custom connectivity update to</p></li>
<li><p><strong>custom_conn_update_model</strong> (<em>CustomConnectivityUpdateModelBase</em><em> | </em><em>str</em>) – custom connectivity update model either as a string referencing a built-in model
(see <a class="reference internal" href="#module-pygenn.custom_connectivity_update_models" title="pygenn.custom_connectivity_update_models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">custom_connectivity_update_models</span></code></a>) or an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">CustomConnectivityUpdateModelBaseUpdateModelBase</span></code>
(for example returned by <a class="reference internal" href="#pygenn.create_custom_connectivity_update_model" title="pygenn.create_custom_connectivity_update_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_custom_connectivity_update_model()</span></code></a>)</p></li>
<li><p><strong>params</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>int</em><em> | </em><em>float</em><em>]</em>) – parameter values for the custom connectivity model (see <a class="reference internal" href="../building_networks.html#section-parameters"><span class="std std-ref">Parameters</span></a>)</p></li>
<li><p><strong>vars</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarInit</em><em> | </em><em>int</em><em> | </em><em>float</em><em> | </em><em>ndarray</em><em> | </em><em>Sequence</em><em>]</em>) – initial synaptic variable values or
initialisers (see <a class="reference internal" href="../building_networks.html#section-variables"><span class="std std-ref">Variables</span></a>)</p></li>
<li><p><strong>pre_vars</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarInit</em><em> | </em><em>int</em><em> | </em><em>float</em><em> | </em><em>ndarray</em><em> | </em><em>Sequence</em><em>]</em>) – initial presynaptic variable values or
initialisers (see <a class="reference internal" href="../building_networks.html#section-variables"><span class="std std-ref">Variables</span></a>)</p></li>
<li><p><strong>post_vars</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarInit</em><em> | </em><em>int</em><em> | </em><em>float</em><em> | </em><em>ndarray</em><em> | </em><em>Sequence</em><em>]</em>) – initial postsynaptic variable values or initialisers
(see <a class="reference internal" href="../building_networks.html#section-variables"><span class="std std-ref">Variables</span></a>)</p></li>
<li><p><strong>var_refs</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>WUVarReference</em><em>]</em>) – references to synaptic variables,
typically created using <a class="reference internal" href="#pygenn.create_wu_var_ref" title="pygenn.create_wu_var_ref"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_wu_var_ref()</span></code></a>
(see <a class="reference internal" href="../building_networks.html#section-variables-references"><span class="std std-ref">Variables references</span></a>)</p></li>
<li><p><strong>pre_var_refs</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarReference</em><em>]</em>) – references to presynaptic variables,
typically created using <a class="reference internal" href="#pygenn.create_var_ref" title="pygenn.create_var_ref"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_var_ref()</span></code></a>
(see <a class="reference internal" href="../building_networks.html#section-variables-references"><span class="std std-ref">Variables references</span></a>)</p></li>
<li><p><strong>post_var_refs</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarReference</em><em>]</em>) – references to postsynaptic variables,
typically created using <a class="reference internal" href="#pygenn.create_var_ref" title="pygenn.create_var_ref"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_var_ref()</span></code></a>
(see <a class="reference internal" href="../building_networks.html#section-variables-references"><span class="std std-ref">Variables references</span></a>)</p></li>
<li><p><strong>egp_refs</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>EGPReference</em><em>]</em>) – references to extra global parameters in other populations
to access from this update, typically created using
<a class="reference internal" href="#pygenn.create_egp_ref" title="pygenn.create_egp_ref"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_egp_ref()</span></code></a> (see <a class="reference internal" href="../building_networks.html#section-extra-global-parameter-references"><span class="std std-ref">Extra global parameter references</span></a>).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.add_custom_update">
<span class="sig-name descname"><span class="pre">add_custom_update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cu_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom_update_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egp_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.add_custom_update" title="Permalink to this definition"></a></dt>
<dd><p>Add a custom update to the GeNN model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cu_name</strong> (<em>str</em>) – unique name</p></li>
<li><p><strong>group_name</strong> (<em>str</em>) – name of the ‘custom update group’ to include this update in.
All custom updates in the same group are executed simultaneously.</p></li>
<li><p><strong>custom_update_model</strong> (<em>CustomUpdateModelBase</em><em> | </em><em>str</em>) – custom update model either as a string referencing a built-in model
(see <a class="reference internal" href="#module-pygenn.custom_update_models" title="pygenn.custom_update_models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">custom_update_models</span></code></a>) or an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">CustomUpdateModelBase</span></code>
(for example returned by <a class="reference internal" href="#pygenn.create_custom_update_model" title="pygenn.create_custom_update_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_custom_update_model()</span></code></a>)</p></li>
<li><p><strong>params</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>int</em><em> | </em><em>float</em><em>]</em>) – parameter values for the custom update model (see <a class="reference internal" href="../building_networks.html#section-parameters"><span class="std std-ref">Parameters</span></a>)</p></li>
<li><p><strong>vars</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarInit</em><em> | </em><em>int</em><em> | </em><em>float</em><em> | </em><em>ndarray</em><em> | </em><em>Sequence</em><em>]</em>) – initial variable values or initialisers
for the custom update model (see <a class="reference internal" href="../building_networks.html#section-variables"><span class="std std-ref">Variables</span></a>)</p></li>
<li><p><strong>var_refs</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarReference</em><em>] </em><em>| </em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>WUVarReference</em><em>]</em>) – references to variables in other populations to
access from this update, typically created using either
<a class="reference internal" href="#pygenn.create_var_ref" title="pygenn.create_var_ref"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_var_ref()</span></code></a> or <a class="reference internal" href="#pygenn.create_wu_var_ref" title="pygenn.create_wu_var_ref"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_wu_var_ref()</span></code></a>
(see <a class="reference internal" href="../building_networks.html#section-variables-references"><span class="std std-ref">Variables references</span></a>).</p></li>
<li><p><strong>egp_refs</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>EGPReference</em><em>]</em>) – references to extra global parameters in other populations
to access from this update, typically created using
<a class="reference internal" href="#pygenn.create_egp_ref" title="pygenn.create_egp_ref"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_egp_ref()</span></code></a> (see <a class="reference internal" href="../building_networks.html#section-extra-global-parameter-references"><span class="std std-ref">Extra global parameter references</span></a>).</p></li>
</ul>
</dd>
</dl>
<p>For example, a custom update to calculate transpose weights could be added to a model as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cu</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">add_custom_update</span><span class="p">(</span><span class="s2">&quot;tranpose_pop&quot;</span><span class="p">,</span> <span class="s2">&quot;transpose&quot;</span><span class="p">,</span> <span class="s2">&quot;Transpose&quot;</span><span class="p">,</span>
                             <span class="n">var_refs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">create_wu_var_ref</span><span class="p">(</span><span class="n">fwd_sg</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">,</span>
                                                                     <span class="n">back_sg</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">)})</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">fwd_sg</span></code> and <code class="docutils literal notranslate"><span class="pre">back_sg</span></code> are references to synapse populations
(as returned by <a class="reference internal" href="#pygenn.GeNNModel.add_synapse_population" title="pygenn.GeNNModel.add_synapse_population"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.add_synapse_population()</span></code></a>). This update
could then subsequently be triggered using the name of it’s update group with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">custom_update</span><span class="p">(</span><span class="s2">&quot;transpose&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.add_neuron_population">
<span class="sig-name descname"><span class="pre">add_neuron_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pop_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_neurons</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neuron</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.add_neuron_population" title="Permalink to this definition"></a></dt>
<dd><p>Add a neuron population to the GeNN model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pop_name</strong> (<em>str</em>) – unique name</p></li>
<li><p><strong>num_neurons</strong> (<em>int</em>) – number of neurons</p></li>
<li><p><strong>neuron</strong> (<em>NeuronModelBase</em><em> | </em><em>str</em>) – neuron model either as a string referencing a built-in model
(see <a class="reference internal" href="#module-pygenn.neuron_models" title="pygenn.neuron_models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">neuron_models</span></code></a>) or an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">NeuronModelBase</span></code>
(for example returned by <a class="reference internal" href="#pygenn.create_neuron_model" title="pygenn.create_neuron_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_neuron_model()</span></code></a>)</p></li>
<li><p><strong>params</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>int</em><em> | </em><em>float</em><em>]</em>) – parameter values for the neuron model (see <a class="reference internal" href="../building_networks.html#section-parameters"><span class="std std-ref">Parameters</span></a>)</p></li>
<li><p><strong>vars</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarInit</em><em> | </em><em>int</em><em> | </em><em>float</em><em> | </em><em>ndarray</em><em> | </em><em>Sequence</em><em>]</em>) – initial variable values or initialisers
for the neuron model (see <a class="reference internal" href="../building_networks.html#section-variables"><span class="std std-ref">Variables</span></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pygenn.NeuronGroup" title="pygenn._genn.NeuronGroup"><em>NeuronGroup</em></a></p>
</dd>
</dl>
<p>For example, a population of 10 neurons using the built-in Izhikevich model and
the standard set of ‘tonic spiking’ parameters could be added to a model as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pop</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">add_neuron_population</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;Izhikevich&quot;</span><span class="p">,</span>
                                  <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mf">0.02</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">65.0</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="mf">6.0</span><span class="p">},</span>
                                  <span class="p">{</span><span class="s2">&quot;V&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">65.0</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">20.0</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.add_synapse_population">
<span class="sig-name descname"><span class="pre">add_synapse_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pop_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_update_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">postsynaptic_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.add_synapse_population" title="Permalink to this definition"></a></dt>
<dd><p>Add a synapse population to the GeNN model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pop_name</strong> (<em>str</em>) – unique name</p></li>
<li><p><strong>matrix_type</strong> (<a class="reference internal" href="#pygenn.SynapseMatrixType" title="pygenn._genn.SynapseMatrixType"><em>SynapseMatrixType</em></a><em> | </em><em>str</em>) – type of connectivity to use</p></li>
<li><p><strong>source</strong> (<a class="reference internal" href="#pygenn.NeuronGroup" title="pygenn._genn.NeuronGroup"><em>NeuronGroup</em></a>) – source neuron group</p></li>
<li><p><strong>target</strong> (<a class="reference internal" href="#pygenn.NeuronGroup" title="pygenn._genn.NeuronGroup"><em>NeuronGroup</em></a>) – target neuron group</p></li>
<li><p><strong>weight_update_init</strong> – initialiser for weight update model, typically
created using <a class="reference internal" href="#pygenn.init_weight_update" title="pygenn.init_weight_update"><code class="xref py py-func docutils literal notranslate"><span class="pre">init_weight_update()</span></code></a></p></li>
<li><p><strong>postsynaptic_init</strong> – initialiser for postsynaptic model, typically
created using <a class="reference internal" href="#pygenn.init_postsynaptic" title="pygenn.init_postsynaptic"><code class="xref py py-func docutils literal notranslate"><span class="pre">init_postsynaptic()</span></code></a></p></li>
<li><p><strong>connectivity_init</strong> (<em>None</em><em> | </em><em>SparseConnectivityInit</em><em> | </em><em>ToeplitzConnectivityInit</em>) – initialiser for connectivity, typically created
using <a class="reference internal" href="#pygenn.init_sparse_connectivity" title="pygenn.init_sparse_connectivity"><code class="xref py py-func docutils literal notranslate"><span class="pre">init_sparse_connectivity()</span></code></a> when
<code class="docutils literal notranslate"><span class="pre">matrix_type</span></code> is <a class="reference internal" href="#pygenn.SynapseMatrixType.BITMASK" title="pygenn.SynapseMatrixType.BITMASK"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixType.BITMASK</span></code></a>,
<a class="reference internal" href="#pygenn.SynapseMatrixType.SPARSE" title="pygenn.SynapseMatrixType.SPARSE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixType.SPARSE</span></code></a>,
<a class="reference internal" href="#pygenn.SynapseMatrixType.PROCEDURAL" title="pygenn.SynapseMatrixType.PROCEDURAL"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixType.PROCEDURAL</span></code></a> or
<a class="reference internal" href="#pygenn.SynapseMatrixType.PROCEDURAL_KERNELG" title="pygenn.SynapseMatrixType.PROCEDURAL_KERNELG"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixType.PROCEDURAL_KERNELG</span></code></a> and with
<code class="xref py py-func docutils literal notranslate"><span class="pre">init_toeplitz_connectivity_connectivity()</span></code> if
it’s <a class="reference internal" href="#pygenn.SynapseMatrixType.TOEPLITZ" title="pygenn.SynapseMatrixType.TOEPLITZ"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixType.TOEPLITZ</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><em>SynapseGroup</em></a></p>
</dd>
</dl>
<p>For example, a neuron population <code class="docutils literal notranslate"><span class="pre">src_pop</span></code> could be connected to another called
<code class="docutils literal notranslate"><span class="pre">target_pop</span></code> using sparse connectivity, static synapses and
exponential shaped current inputs as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pop</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">add_synapse_population</span><span class="p">(</span><span class="s2">&quot;Syn&quot;</span><span class="p">,</span> <span class="s2">&quot;SPARSE&quot;</span><span class="p">,</span>
                                   <span class="n">src_pop</span><span class="p">,</span> <span class="n">target_pop</span><span class="p">,</span>
                                   <span class="n">init_weight_update</span><span class="p">(</span><span class="s2">&quot;StaticPulseConstantWeight&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">}),</span>
                                   <span class="n">init_postsynaptic</span><span class="p">(</span><span class="s2">&quot;ExpCurr&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;tau&quot;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">}),</span>
                                   <span class="n">init_sparse_connectivity</span><span class="p">(</span><span class="s2">&quot;FixedProbability&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;prob&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">}))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.GeNNModel.backend_name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backend_name</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">str</span></em><a class="headerlink" href="#pygenn.GeNNModel.backend_name" title="Permalink to this definition"></a></dt>
<dd><p>Name of the currently selected backend</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">always_rebuild</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">never_rebuild</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.build" title="Permalink to this definition"></a></dt>
<dd><p>Finalize and build a GeNN model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_to_model</strong> (<em>str</em>) – path where to place the generated model code.
Defaults to the local directory.</p></li>
<li><p><strong>always_rebuild</strong> (<em>bool</em>) – should model be rebuilt even if
it doesn’t appear to be required</p></li>
<li><p><strong>never_rebuild</strong> (<em>bool</em>) – should model never be rebuilt even it appears to
need it. This should only ever be used to prevent
file overwriting when performing parallel runs</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.custom_update">
<span class="sig-name descname"><span class="pre">custom_update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.custom_update" title="Permalink to this definition"></a></dt>
<dd><p>Perform custom update</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of custom update. Corresponds to the <code class="docutils literal notranslate"><span class="pre">group_name</span></code>
parameter passed to <a class="reference internal" href="#pygenn.GeNNModel.add_custom_update" title="pygenn.GeNNModel.add_custom_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_custom_update()</span></code></a> and
<a class="reference internal" href="#pygenn.GeNNModel.add_custom_connectivity_update" title="pygenn.GeNNModel.add_custom_connectivity_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_custom_connectivity_update()</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.GeNNModel.dT">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dT</span></span><a class="headerlink" href="#pygenn.GeNNModel.dT" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.get_custom_update_time">
<span class="sig-name descname"><span class="pre">get_custom_update_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.get_custom_update_time" title="Permalink to this definition"></a></dt>
<dd><p>Get time in seconds spent in custom update.
Only available if <a class="reference internal" href="#pygenn.ModelSpec.timing_enabled" title="pygenn.ModelSpec.timing_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ModelSpec.timing_enabled</span></code></a> is set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of custom update</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.get_custom_update_transpose_time">
<span class="sig-name descname"><span class="pre">get_custom_update_transpose_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.get_custom_update_transpose_time" title="Permalink to this definition"></a></dt>
<dd><p>Get time in seconds spent in transpose custom update.
Only available if <a class="reference internal" href="#pygenn.ModelSpec.timing_enabled" title="pygenn.ModelSpec.timing_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ModelSpec.timing_enabled</span></code></a> is set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of custom update</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.GeNNModel.init_sparse_time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">init_sparse_time</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#pygenn.GeNNModel.init_sparse_time" title="Permalink to this definition"></a></dt>
<dd><p>Time in seconds spent in sparse initialisation kernel.
Only available if <a class="reference internal" href="#pygenn.ModelSpec.timing_enabled" title="pygenn.ModelSpec.timing_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ModelSpec.timing_enabled</span></code></a> is set</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.GeNNModel.init_time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">init_time</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#pygenn.GeNNModel.init_time" title="Permalink to this definition"></a></dt>
<dd><p>Time in seconds spent initialisation kernel.
Only available if <a class="reference internal" href="#pygenn.ModelSpec.timing_enabled" title="pygenn.ModelSpec.timing_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ModelSpec.timing_enabled</span></code></a> is set</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.load">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_recording_timesteps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.load" title="Permalink to this definition"></a></dt>
<dd><p>Load the previously built model into memory;</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_recording_timesteps</strong> (<em>int</em><em> | </em><em>None</em>) – Number of timesteps to record spikes
for. <a class="reference internal" href="#pygenn.GeNNModel.pull_recording_buffers_from_device" title="pygenn.GeNNModel.pull_recording_buffers_from_device"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pull_recording_buffers_from_device()</span></code></a>
must be called after this number of timesteps</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.GeNNModel.neuron_update_time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">neuron_update_time</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#pygenn.GeNNModel.neuron_update_time" title="Permalink to this definition"></a></dt>
<dd><p>Time in seconds spent in neuron update kernel.
Only available if <a class="reference internal" href="#pygenn.ModelSpec.timing_enabled" title="pygenn.ModelSpec.timing_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ModelSpec.timing_enabled</span></code></a> is set</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.GeNNModel.postsynaptic_update_time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">postsynaptic_update_time</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#pygenn.GeNNModel.postsynaptic_update_time" title="Permalink to this definition"></a></dt>
<dd><p>Time in seconds spent in postsynaptic update kernel.
Only available if <a class="reference internal" href="#pygenn.ModelSpec.timing_enabled" title="pygenn.ModelSpec.timing_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ModelSpec.timing_enabled</span></code></a> is set</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.GeNNModel.presynaptic_update_time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">presynaptic_update_time</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#pygenn.GeNNModel.presynaptic_update_time" title="Permalink to this definition"></a></dt>
<dd><p>Time in seconds spent in presynaptic update kernel.
Only available if <a class="reference internal" href="#pygenn.ModelSpec.timing_enabled" title="pygenn.ModelSpec.timing_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ModelSpec.timing_enabled</span></code></a> is set</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.pull_recording_buffers_from_device">
<span class="sig-name descname"><span class="pre">pull_recording_buffers_from_device</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.pull_recording_buffers_from_device" title="Permalink to this definition"></a></dt>
<dd><p>Pull recording buffers from device</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.step_time">
<span class="sig-name descname"><span class="pre">step_time</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.step_time" title="Permalink to this definition"></a></dt>
<dd><p>Make one simulation step</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.GeNNModel.synapse_dynamics_time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">synapse_dynamics_time</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#pygenn.GeNNModel.synapse_dynamics_time" title="Permalink to this definition"></a></dt>
<dd><p>Time in seconds spent in synapse dynamics kernel.
Only available if <a class="reference internal" href="#pygenn.ModelSpec.timing_enabled" title="pygenn.ModelSpec.timing_enabled"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ModelSpec.timing_enabled</span></code></a> is set</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.GeNNModel.t">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">t</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#pygenn.GeNNModel.t" title="Permalink to this definition"></a></dt>
<dd><p>Simulation time in ms</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.GeNNModel.timestep">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">timestep</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#pygenn.GeNNModel.timestep" title="Permalink to this definition"></a></dt>
<dd><p>Simulation time step</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.GeNNModel.unload">
<span class="sig-name descname"><span class="pre">unload</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.GeNNModel.unload" title="Permalink to this definition"></a></dt>
<dd><p>Unload a previously loaded model, freeing all memory</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.ModelSpec">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">ModelSpec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.ModelSpec" title="pygenn._genn.ModelSpec"><span class="pre">pygenn._genn.ModelSpec</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.ModelSpec" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.batch_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">batch_size</span></span><a class="headerlink" href="#pygenn.ModelSpec.batch_size" title="Permalink to this definition"></a></dt>
<dd><p>Batch size of this model - efficiently duplicates model</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.default_narrow_sparse_ind_enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_narrow_sparse_ind_enabled</span></span><a class="headerlink" href="#pygenn.ModelSpec.default_narrow_sparse_ind_enabled" title="Permalink to this definition"></a></dt>
<dd><p>Should ‘narrow’ i.e. less than 32-bit types be used to store postsyanptic neuron indices in SynapseMatrixConnectivity::SPARSE connectivity?
If this is true and postsynaptic population has &lt; 256 neurons, 8-bit indices will be used and,
if it has &lt; 65536 neurons, 16-bit indices will be used.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.default_sparse_connectivity_location">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_sparse_connectivity_location</span></span><a class="headerlink" href="#pygenn.ModelSpec.default_sparse_connectivity_location" title="Permalink to this definition"></a></dt>
<dd><p>The default location for sparse synaptic connectivity</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.default_var_location">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_var_location</span></span><a class="headerlink" href="#pygenn.ModelSpec.default_var_location" title="Permalink to this definition"></a></dt>
<dd><p>The default location for model state variables?</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.dt">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dt</span></span><a class="headerlink" href="#pygenn.ModelSpec.dt" title="Permalink to this definition"></a></dt>
<dd><p>The integration time step of the model</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.fuse_postsynaptic_models">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fuse_postsynaptic_models</span></span><a class="headerlink" href="#pygenn.ModelSpec.fuse_postsynaptic_models" title="Permalink to this definition"></a></dt>
<dd><p>Should compatible postsynaptic models and dendritic delay buffers be fused?
This can significantly reduce the cost of updating neuron population but means that per-synapse group inSyn arrays can not be retrieved</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.fuse_pre_post_weight_update_models">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fuse_pre_post_weight_update_models</span></span><a class="headerlink" href="#pygenn.ModelSpec.fuse_pre_post_weight_update_models" title="Permalink to this definition"></a></dt>
<dd><p>Should compatible pre and postsynaptic weight update model variables and updates be fused?
This can significantly reduce the cost of updating neuron populations but means that per-synaptic group per and postsynaptic variables cannot be retrieved</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.ModelSpec.name" title="Permalink to this definition"></a></dt>
<dd><p>Name of the network model</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.num_neurons">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_neurons</span></span><a class="headerlink" href="#pygenn.ModelSpec.num_neurons" title="Permalink to this definition"></a></dt>
<dd><p>How many neurons make up the entire model</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.precision">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">precision</span></span><a class="headerlink" href="#pygenn.ModelSpec.precision" title="Permalink to this definition"></a></dt>
<dd><p>Type of floating point variables used for ‘scalar’ types</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.seed">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">seed</span></span><a class="headerlink" href="#pygenn.ModelSpec.seed" title="Permalink to this definition"></a></dt>
<dd><p>RNG seed</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.time_precision">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">time_precision</span></span><a class="headerlink" href="#pygenn.ModelSpec.time_precision" title="Permalink to this definition"></a></dt>
<dd><p>Type of floating point variables used for ‘timepoint’ types</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ModelSpec.timing_enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">timing_enabled</span></span><a class="headerlink" href="#pygenn.ModelSpec.timing_enabled" title="Permalink to this definition"></a></dt>
<dd><p>Whether timing code should be inserted into model</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.NeuronGroup">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">NeuronGroup</span></span><a class="headerlink" href="#pygenn.NeuronGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code>, <a class="reference internal" href="#pygenn.genn_groups.NeuronGroupMixin" title="pygenn.genn_groups.NeuronGroupMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">NeuronGroupMixin</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.get_var_location">
<span class="sig-name descname"><span class="pre">get_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.NeuronGroup" title="pygenn._genn.NeuronGroup"><span class="pre">pygenn._genn.NeuronGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></span><a class="headerlink" href="#pygenn.NeuronGroup.get_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Get location of neuron model state variable by name</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#pygenn.NeuronGroup.model" title="Permalink to this definition"></a></dt>
<dd><p>Neuron model used for this group</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.NeuronGroup.name" title="Permalink to this definition"></a></dt>
<dd><p>Unique name of neuron group</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.num_neurons">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_neurons</span></span><a class="headerlink" href="#pygenn.NeuronGroup.num_neurons" title="Permalink to this definition"></a></dt>
<dd><p>Number of neurons in group</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.params">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">params</span></span><a class="headerlink" href="#pygenn.NeuronGroup.params" title="Permalink to this definition"></a></dt>
<dd><p>Values of neuron parameters</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.prev_spike_time_location">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">prev_spike_time_location</span></span><a class="headerlink" href="#pygenn.NeuronGroup.prev_spike_time_location" title="Permalink to this definition"></a></dt>
<dd><p>Location of previous spike times.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.recording_zero_copy_enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">recording_zero_copy_enabled</span></span><a class="headerlink" href="#pygenn.NeuronGroup.recording_zero_copy_enabled" title="Permalink to this definition"></a></dt>
<dd><p>Should zero-copy memory (if available) be used
for spike and spike-like event recording?</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.set_param_dynamic">
<span class="sig-name descname"><span class="pre">set_param_dynamic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.NeuronGroup" title="pygenn._genn.NeuronGroup"><span class="pre">pygenn._genn.NeuronGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.NeuronGroup.set_param_dynamic" title="Permalink to this definition"></a></dt>
<dd><p>Set whether parameter is dynamic or not i.e. it can be changed at runtime</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.set_var_location">
<span class="sig-name descname"><span class="pre">set_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.NeuronGroup" title="pygenn._genn.NeuronGroup"><span class="pre">pygenn._genn.NeuronGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.NeuronGroup.set_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Set variable location of neuron model state variable.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.spike_event_recording_enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">spike_event_recording_enabled</span></span><a class="headerlink" href="#pygenn.NeuronGroup.spike_event_recording_enabled" title="Permalink to this definition"></a></dt>
<dd><p>Is spike event recording enabled?</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.spike_recording_enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">spike_recording_enabled</span></span><a class="headerlink" href="#pygenn.NeuronGroup.spike_recording_enabled" title="Permalink to this definition"></a></dt>
<dd><p>Is spike recording enabled for this population?</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.NeuronGroup.spike_time_location">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">spike_time_location</span></span><a class="headerlink" href="#pygenn.NeuronGroup.spike_time_location" title="Permalink to this definition"></a></dt>
<dd><p>Location of spike times from neuron group.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.ParallelismHint">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">ParallelismHint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.ParallelismHint" title="pygenn._genn.ParallelismHint"><span class="pre">pygenn._genn.ParallelismHint</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.ParallelismHint" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Hints to backends as to what parallelism strategy to use for this synapse group</p>
<p>Members:</p>
<blockquote>
<div><p>POSTSYNAPTIC : GPU threads loop over spikes and handle all connectivity associated with</p>
</div></blockquote>
<p>a postsynaptic neuron or column of sparse connectivity.
Generally, this is the most efficient approach and memory accesses are
coalesced and, while atomic operations are used, there should be minimal
conflicts between them.</p>
<blockquote>
<div><p>PRESYNAPTIC : GPU threads</p>
</div></blockquote>
<p>If spike rates are high, this can extract more parallelism but there is an
overhead to launching numerous threads with no spike to process and this
approach does not result in well-coalesced memory accesses.</p>
<blockquote>
<div><p>WORD_PACKED_BITMASK : Rather than processing SynapseMatrixConnectivity::BITMASK connectivity</p>
</div></blockquote>
<p>using one thread per postsynaptic neuron and doing nothing when a zero
is encountered, process 32 bits of bitmask using each thread.
On the single-threaded CPU backend and when simulating models with
significantly more neurons than the target GPU has threads,
this is likely to improve performance.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.ParallelismHint.POSTSYNAPTIC">
<span class="sig-name descname"><span class="pre">POSTSYNAPTIC</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ParallelismHint.POSTSYNAPTIC:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pygenn.ParallelismHint.POSTSYNAPTIC" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.ParallelismHint.PRESYNAPTIC">
<span class="sig-name descname"><span class="pre">PRESYNAPTIC</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ParallelismHint.PRESYNAPTIC:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pygenn.ParallelismHint.PRESYNAPTIC" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.ParallelismHint.WORD_PACKED_BITMASK">
<span class="sig-name descname"><span class="pre">WORD_PACKED_BITMASK</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ParallelismHint.WORD_PACKED_BITMASK:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pygenn.ParallelismHint.WORD_PACKED_BITMASK" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ParallelismHint.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.ParallelismHint.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.ParallelismHint.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.ParallelismHint.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.PlogSeverity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">PlogSeverity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.PlogSeverity" title="pygenn._genn.PlogSeverity"><span class="pre">pygenn._genn.PlogSeverity</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.PlogSeverity" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Members:</p>
<p>NONE</p>
<p>FATAL</p>
<p>ERROR</p>
<p>WARNING</p>
<p>INFO</p>
<p>DEBUG</p>
<p>VERBOSE</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.PlogSeverity.DEBUG">
<span class="sig-name descname"><span class="pre">DEBUG</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;PlogSeverity.DEBUG:</span> <span class="pre">5&gt;</span></em><a class="headerlink" href="#pygenn.PlogSeverity.DEBUG" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.PlogSeverity.ERROR">
<span class="sig-name descname"><span class="pre">ERROR</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;PlogSeverity.ERROR:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pygenn.PlogSeverity.ERROR" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.PlogSeverity.FATAL">
<span class="sig-name descname"><span class="pre">FATAL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;PlogSeverity.FATAL:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pygenn.PlogSeverity.FATAL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.PlogSeverity.INFO">
<span class="sig-name descname"><span class="pre">INFO</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;PlogSeverity.INFO:</span> <span class="pre">4&gt;</span></em><a class="headerlink" href="#pygenn.PlogSeverity.INFO" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.PlogSeverity.NONE">
<span class="sig-name descname"><span class="pre">NONE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;PlogSeverity.NONE:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pygenn.PlogSeverity.NONE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.PlogSeverity.VERBOSE">
<span class="sig-name descname"><span class="pre">VERBOSE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;PlogSeverity.VERBOSE:</span> <span class="pre">6&gt;</span></em><a class="headerlink" href="#pygenn.PlogSeverity.VERBOSE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.PlogSeverity.WARNING">
<span class="sig-name descname"><span class="pre">WARNING</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;PlogSeverity.WARNING:</span> <span class="pre">3&gt;</span></em><a class="headerlink" href="#pygenn.PlogSeverity.WARNING" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.PlogSeverity.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.PlogSeverity.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.PlogSeverity.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.PlogSeverity.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.SynapseGroup">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">SynapseGroup</span></span><a class="headerlink" href="#pygenn.SynapseGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code>, <a class="reference internal" href="#pygenn.genn_groups.SynapseGroupMixin" title="pygenn.genn_groups.SynapseGroupMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">SynapseGroupMixin</span></code></a></p>
<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.axonal_delay_steps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">axonal_delay_steps</span></span><a class="headerlink" href="#pygenn.SynapseGroup.axonal_delay_steps" title="Permalink to this definition"></a></dt>
<dd><p>Global synaptic conductance delay for the group (in time steps)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.back_prop_delay_steps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">back_prop_delay_steps</span></span><a class="headerlink" href="#pygenn.SynapseGroup.back_prop_delay_steps" title="Permalink to this definition"></a></dt>
<dd><p>Global backpropagation delay for postsynaptic spikes to synapse (in time steps)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.dendritic_delay_location">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dendritic_delay_location</span></span><a class="headerlink" href="#pygenn.SynapseGroup.dendritic_delay_location" title="Permalink to this definition"></a></dt>
<dd><p>Location of this synapse group’s dendritic delay buffers.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.get_ps_var_location">
<span class="sig-name descname"><span class="pre">get_ps_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><span class="pre">pygenn._genn.SynapseGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></span><a class="headerlink" href="#pygenn.SynapseGroup.get_ps_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Get location of postsynaptic model state variable</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.get_wu_post_var_location">
<span class="sig-name descname"><span class="pre">get_wu_post_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><span class="pre">pygenn._genn.SynapseGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></span><a class="headerlink" href="#pygenn.SynapseGroup.get_wu_post_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Get location of weight update model postsynaptic state variable</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.get_wu_pre_var_location">
<span class="sig-name descname"><span class="pre">get_wu_pre_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><span class="pre">pygenn._genn.SynapseGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></span><a class="headerlink" href="#pygenn.SynapseGroup.get_wu_pre_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Get location of weight update model presynaptic state variable</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.get_wu_var_location">
<span class="sig-name descname"><span class="pre">get_wu_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><span class="pre">pygenn._genn.SynapseGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></span><a class="headerlink" href="#pygenn.SynapseGroup.get_wu_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Get location of weight update model synaptic state variable</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.kernel_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#pygenn.SynapseGroup.kernel_size" title="Permalink to this definition"></a></dt>
<dd><p>Kernel size</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.matrix_type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix_type</span></span><a class="headerlink" href="#pygenn.SynapseGroup.matrix_type" title="Permalink to this definition"></a></dt>
<dd><p>Connectivity type of synapses</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.max_connections">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_connections</span></span><a class="headerlink" href="#pygenn.SynapseGroup.max_connections" title="Permalink to this definition"></a></dt>
<dd><p>Maximum number of target neurons any source neuron can connect to</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.max_dendritic_delay_timesteps">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_dendritic_delay_timesteps</span></span><a class="headerlink" href="#pygenn.SynapseGroup.max_dendritic_delay_timesteps" title="Permalink to this definition"></a></dt>
<dd><p>Maximum dendritic delay timesteps supported for synapses in this population</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.max_source_connections">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_source_connections</span></span><a class="headerlink" href="#pygenn.SynapseGroup.max_source_connections" title="Permalink to this definition"></a></dt>
<dd><p>Maximum number of source neurons any target neuron can connect to</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.SynapseGroup.name" title="Permalink to this definition"></a></dt>
<dd><p>Name of the synapse group</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.narrow_sparse_ind_enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">narrow_sparse_ind_enabled</span></span><a class="headerlink" href="#pygenn.SynapseGroup.narrow_sparse_ind_enabled" title="Permalink to this definition"></a></dt>
<dd><p>Should narrow i.e. less than 32-bit types be used for sparse matrix indices</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.num_threads_per_spike">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_threads_per_spike</span></span><a class="headerlink" href="#pygenn.SynapseGroup.num_threads_per_spike" title="Permalink to this definition"></a></dt>
<dd><p>How many threads GPU implementation use to process each spike when parallelised presynaptically</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.output_location">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_location</span></span><a class="headerlink" href="#pygenn.SynapseGroup.output_location" title="Permalink to this definition"></a></dt>
<dd><p>Location of outputs from this synapse group e.g. outPre and outPost.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.parallelism_hint">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">parallelism_hint</span></span><a class="headerlink" href="#pygenn.SynapseGroup.parallelism_hint" title="Permalink to this definition"></a></dt>
<dd><p>Hint as to how synapse group should be parallelised</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.post_target_var">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">post_target_var</span></span><a class="headerlink" href="#pygenn.SynapseGroup.post_target_var" title="Permalink to this definition"></a></dt>
<dd><p>Name of neuron input variable postsynaptic model will target.
This should either be ‘Isyn’ or the name of one of the postsynaptic neuron’s additional input variables.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.pre_target_var">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pre_target_var</span></span><a class="headerlink" href="#pygenn.SynapseGroup.pre_target_var" title="Permalink to this definition"></a></dt>
<dd><p>Name of neuron input variable a presynaptic output specified with $(addToPre) will target.
This will either be ‘Isyn’ or the name of one of the presynaptic neuron’s additional input variables.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.ps_initialiser">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ps_initialiser</span></span><a class="headerlink" href="#pygenn.SynapseGroup.ps_initialiser" title="Permalink to this definition"></a></dt>
<dd><p>Initialiser used for creating postsynaptic update model</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.set_ps_param_dynamic">
<span class="sig-name descname"><span class="pre">set_ps_param_dynamic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><span class="pre">pygenn._genn.SynapseGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.SynapseGroup.set_ps_param_dynamic" title="Permalink to this definition"></a></dt>
<dd><p>Set whether weight update model parameter is dynamic or not i.e. it can be changed at runtime</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.set_ps_var_location">
<span class="sig-name descname"><span class="pre">set_ps_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><span class="pre">pygenn._genn.SynapseGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.SynapseGroup.set_ps_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Set location of postsynaptic model state variable.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.set_wu_param_dynamic">
<span class="sig-name descname"><span class="pre">set_wu_param_dynamic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><span class="pre">pygenn._genn.SynapseGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.SynapseGroup.set_wu_param_dynamic" title="Permalink to this definition"></a></dt>
<dd><p>Set whether weight update model parameter is dynamic or not i.e. it can be changed at runtime</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.set_wu_post_var_location">
<span class="sig-name descname"><span class="pre">set_wu_post_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><span class="pre">pygenn._genn.SynapseGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.SynapseGroup.set_wu_post_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Set location of weight update model postsynaptic state variable.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.set_wu_pre_var_location">
<span class="sig-name descname"><span class="pre">set_wu_pre_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><span class="pre">pygenn._genn.SynapseGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.SynapseGroup.set_wu_pre_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Set location of weight update model presynaptic state variable.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.set_wu_var_location">
<span class="sig-name descname"><span class="pre">set_wu_var_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseGroup" title="pygenn._genn.SynapseGroup"><span class="pre">pygenn._genn.SynapseGroup</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pygenn.SynapseGroup.set_wu_var_location" title="Permalink to this definition"></a></dt>
<dd><p>Set location of weight update model state variable.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.sparse_connectivity_initialiser">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sparse_connectivity_initialiser</span></span><a class="headerlink" href="#pygenn.SynapseGroup.sparse_connectivity_initialiser" title="Permalink to this definition"></a></dt>
<dd><p>Initialiser used for creating sparse connectivity</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.sparse_connectivity_location">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sparse_connectivity_location</span></span><a class="headerlink" href="#pygenn.SynapseGroup.sparse_connectivity_location" title="Permalink to this definition"></a></dt>
<dd><p>Location of sparse connectivity.
This is ignored for simulations on hardware with a single memory space</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.toeplitz_connectivity_initialiser">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">toeplitz_connectivity_initialiser</span></span><a class="headerlink" href="#pygenn.SynapseGroup.toeplitz_connectivity_initialiser" title="Permalink to this definition"></a></dt>
<dd><p>Initialiser used for creating toeplitz connectivity</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseGroup.wu_initialiser">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wu_initialiser</span></span><a class="headerlink" href="#pygenn.SynapseGroup.wu_initialiser" title="Permalink to this definition"></a></dt>
<dd><p>Initialiser used for creating weight update model</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixConnectivity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">SynapseMatrixConnectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseMatrixConnectivity" title="pygenn._genn.SynapseMatrixConnectivity"><span class="pre">pygenn._genn.SynapseMatrixConnectivity</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.SynapseMatrixConnectivity" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Flags defining how synaptic connectivity is represented</p>
<p>Members:</p>
<blockquote>
<div><p>DENSE : Connectivity is dense with a synapse between each pair of pre and postsynaptic neurons</p>
<p>BITMASK : Connectivity is sparse and stored using a bitmask.</p>
<p>SPARSE : Connectivity is sparse and stored using a compressed sparse row data structure</p>
<p>PROCEDURAL : Connectivity is generated on the fly using a sparse connectivity initialisation snippet</p>
<p>TOEPLITZ : Connectivity is generated on the fly using a Toeplitz connectivity initialisation snippet</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixConnectivity.BITMASK">
<span class="sig-name descname"><span class="pre">BITMASK</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixConnectivity.BITMASK:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixConnectivity.BITMASK" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixConnectivity.DENSE">
<span class="sig-name descname"><span class="pre">DENSE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixConnectivity.DENSE:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixConnectivity.DENSE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixConnectivity.PROCEDURAL">
<span class="sig-name descname"><span class="pre">PROCEDURAL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixConnectivity.PROCEDURAL:</span> <span class="pre">8&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixConnectivity.PROCEDURAL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixConnectivity.SPARSE">
<span class="sig-name descname"><span class="pre">SPARSE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixConnectivity.SPARSE:</span> <span class="pre">4&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixConnectivity.SPARSE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixConnectivity.TOEPLITZ">
<span class="sig-name descname"><span class="pre">TOEPLITZ</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixConnectivity.TOEPLITZ:</span> <span class="pre">16&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixConnectivity.TOEPLITZ" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixConnectivity.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.SynapseMatrixConnectivity.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixConnectivity.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.SynapseMatrixConnectivity.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">SynapseMatrixType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseMatrixType" title="pygenn._genn.SynapseMatrixType"><span class="pre">pygenn._genn.SynapseMatrixType</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.SynapseMatrixType" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Members:</p>
<blockquote>
<div><p>DENSE : Synaptic matrix is dense and synaptic state variables are stored individually in memory.</p>
<p>DENSE_PROCEDURALG : Synaptic matrix is dense and all synaptic state variables must either be constant or generated on the fly using their variable initialisation snippets.</p>
<p>BITMASK : Connectivity is stored as a bitmask.</p>
</div></blockquote>
<p>For moderately sparse (&gt;3%) connectivity, this uses the least memory. However, connectivity of this sort cannot
have any accompanying state variables. Which algorithm is used for propagating spikes through BITMASK connectivity can be hinted via
SynapseGroup::ParallelismHint.</p>
<blockquote>
<div><p>SPARSE : Connectivity is stored using a compressed sparse row data structure and synaptic state variables are stored individually in memory.</p>
</div></blockquote>
<p>This is the most efficient choice for very sparse unstructured connectivity or if synaptic state variables are required.</p>
<blockquote>
<div><p>PROCEDURAL : Sparse synaptic connectivity is generated on the fly using a sparse connectivity initialisation snippet and  all state variables must be either constant or generated on the fly using variable initialisation snippets.</p>
</div></blockquote>
<p>Synaptic connectivity of this sort requires very little memory allowing extremely large models to be simulated on a single GPU.</p>
<blockquote>
<div><p>PROCEDURAL_KERNELG : Sparse synaptic connectivity is generated on the fly using a sparse connectivity initialisation snippet and state variables are stored in a shared kernel.</p>
<p>TOEPLITZ : Sparse structured connectivity is generated on the fly a Toeplitz connectivity initialisation snippet and state variables are stored in a shared kernel.</p>
</div></blockquote>
<p>This is the most efficient choice for convolution-like connectivity</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixType.BITMASK">
<span class="sig-name descname"><span class="pre">BITMASK</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixType.BITMASK:</span> <span class="pre">66&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixType.BITMASK" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixType.DENSE">
<span class="sig-name descname"><span class="pre">DENSE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixType.DENSE:</span> <span class="pre">65&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixType.DENSE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixType.DENSE_PROCEDURALG">
<span class="sig-name descname"><span class="pre">DENSE_PROCEDURALG</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixType.DENSE_PROCEDURALG:</span> <span class="pre">129&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixType.DENSE_PROCEDURALG" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixType.PROCEDURAL">
<span class="sig-name descname"><span class="pre">PROCEDURAL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixType.PROCEDURAL:</span> <span class="pre">136&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixType.PROCEDURAL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixType.PROCEDURAL_KERNELG">
<span class="sig-name descname"><span class="pre">PROCEDURAL_KERNELG</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixType.PROCEDURAL_KERNELG:</span> <span class="pre">264&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixType.PROCEDURAL_KERNELG" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixType.SPARSE">
<span class="sig-name descname"><span class="pre">SPARSE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixType.SPARSE:</span> <span class="pre">68&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixType.SPARSE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixType.TOEPLITZ">
<span class="sig-name descname"><span class="pre">TOEPLITZ</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixType.TOEPLITZ:</span> <span class="pre">272&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixType.TOEPLITZ" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixType.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.SynapseMatrixType.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixType.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.SynapseMatrixType.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixWeight">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">SynapseMatrixWeight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.SynapseMatrixWeight" title="pygenn._genn.SynapseMatrixWeight"><span class="pre">pygenn._genn.SynapseMatrixWeight</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.SynapseMatrixWeight" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Flags defining how synaptic state variables are stored</p>
<p>Members:</p>
<blockquote>
<div><p>INDIVIDUAL : Synaptic state variables are stored individually in memory</p>
<p>PROCEDURAL : Synaptic state is generated on the fly using a sparse connectivity initialisation snippet</p>
<p>KERNEL : Synaptic state variables are stored in a kernel which is shared between synapses in</p>
</div></blockquote>
<p>a manner defined by either a Toeplitz or sparse connectivity initialisation snippet</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixWeight.INDIVIDUAL">
<span class="sig-name descname"><span class="pre">INDIVIDUAL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixWeight.INDIVIDUAL:</span> <span class="pre">64&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixWeight.INDIVIDUAL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixWeight.KERNEL">
<span class="sig-name descname"><span class="pre">KERNEL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixWeight.KERNEL:</span> <span class="pre">256&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixWeight.KERNEL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixWeight.PROCEDURAL">
<span class="sig-name descname"><span class="pre">PROCEDURAL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;SynapseMatrixWeight.PROCEDURAL:</span> <span class="pre">128&gt;</span></em><a class="headerlink" href="#pygenn.SynapseMatrixWeight.PROCEDURAL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixWeight.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.SynapseMatrixWeight.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.SynapseMatrixWeight.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.SynapseMatrixWeight.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.VarAccess">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">VarAccess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarAccess" title="pygenn._genn.VarAccess"><span class="pre">pygenn._genn.VarAccess</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.VarAccess" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Supported combinations of access mode and dimension for neuron and synapse variables</p>
<p>Members:</p>
<blockquote>
<div><p>READ_WRITE : This variable can be read from and written to and stores separate values for each element and each batch</p>
<p>READ_ONLY : This variable can only be read from and stores separate values for each element but these are shared across batches</p>
<p>READ_ONLY_DUPLICATE : This variable can only be read from and stores separate values for each element and each batch</p>
<p>READ_ONLY_SHARED_NEURON : This variable can only be read from and stores separate values for each batch but these are shared across neurons</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccess.READ_ONLY">
<span class="sig-name descname"><span class="pre">READ_ONLY</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccess.READ_ONLY:</span> <span class="pre">33&gt;</span></em><a class="headerlink" href="#pygenn.VarAccess.READ_ONLY" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccess.READ_ONLY_DUPLICATE">
<span class="sig-name descname"><span class="pre">READ_ONLY_DUPLICATE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccess.READ_ONLY_DUPLICATE:</span> <span class="pre">97&gt;</span></em><a class="headerlink" href="#pygenn.VarAccess.READ_ONLY_DUPLICATE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccess.READ_ONLY_SHARED_NEURON">
<span class="sig-name descname"><span class="pre">READ_ONLY_SHARED_NEURON</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccess.READ_ONLY_SHARED_NEURON:</span> <span class="pre">65&gt;</span></em><a class="headerlink" href="#pygenn.VarAccess.READ_ONLY_SHARED_NEURON" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccess.READ_WRITE">
<span class="sig-name descname"><span class="pre">READ_WRITE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccess.READ_WRITE:</span> <span class="pre">98&gt;</span></em><a class="headerlink" href="#pygenn.VarAccess.READ_WRITE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarAccess.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.VarAccess.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarAccess.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.VarAccess.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.VarAccessDim">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">VarAccessDim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarAccessDim" title="pygenn._genn.VarAccessDim"><span class="pre">pygenn._genn.VarAccessDim</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.VarAccessDim" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Flags defining dimensions this variables has</p>
<p>Members:</p>
<blockquote>
<div><p>ELEMENT : This variable stores separate values for each element i.e. neuron or synapse</p>
<p>BATCH : This variable stores separate values for each batch</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccessDim.BATCH">
<span class="sig-name descname"><span class="pre">BATCH</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccessDim.BATCH:</span> <span class="pre">64&gt;</span></em><a class="headerlink" href="#pygenn.VarAccessDim.BATCH" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccessDim.ELEMENT">
<span class="sig-name descname"><span class="pre">ELEMENT</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccessDim.ELEMENT:</span> <span class="pre">32&gt;</span></em><a class="headerlink" href="#pygenn.VarAccessDim.ELEMENT" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarAccessDim.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.VarAccessDim.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarAccessDim.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.VarAccessDim.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.VarAccessMode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">VarAccessMode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><span class="pre">pygenn._genn.VarAccessMode</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.VarAccessMode" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Members:</p>
<p>READ_WRITE : This variable can be read from or written to</p>
<p>READ_ONLY : This variable can only be read from</p>
<p>REDUCE_SUM : This variable is a target for a reduction with a sum operation</p>
<p>REDUCE_MAX : This variable is a target for a reduction with a max operation</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccessMode.READ_ONLY">
<span class="sig-name descname"><span class="pre">READ_ONLY</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccessMode.READ_ONLY:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pygenn.VarAccessMode.READ_ONLY" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccessMode.READ_WRITE">
<span class="sig-name descname"><span class="pre">READ_WRITE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccessMode.READ_WRITE:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pygenn.VarAccessMode.READ_WRITE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccessMode.REDUCE_MAX">
<span class="sig-name descname"><span class="pre">REDUCE_MAX</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccessMode.REDUCE_MAX:</span> <span class="pre">20&gt;</span></em><a class="headerlink" href="#pygenn.VarAccessMode.REDUCE_MAX" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccessMode.REDUCE_SUM">
<span class="sig-name descname"><span class="pre">REDUCE_SUM</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccessMode.REDUCE_SUM:</span> <span class="pre">12&gt;</span></em><a class="headerlink" href="#pygenn.VarAccessMode.REDUCE_SUM" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarAccessMode.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.VarAccessMode.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarAccessMode.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.VarAccessMode.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.VarAccessModeAttribute">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">VarAccessModeAttribute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarAccessModeAttribute" title="pygenn._genn.VarAccessModeAttribute"><span class="pre">pygenn._genn.VarAccessModeAttribute</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.VarAccessModeAttribute" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Flags defining attributes of var access models
Read-only and read-write are separate flags rather than read and write so you can test mode &amp; VarAccessMode::READ_ONLY</p>
<p>Members:</p>
<blockquote>
<div><p>READ_ONLY : This variable can only be read from</p>
<p>READ_WRITE : This variable can be read from or written to</p>
<p>REDUCE : This variable is a reduction target</p>
<p>SUM : This variable’s reduction operation is a summation</p>
<p>MAX : This variable’s reduction operation is a maximum</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccessModeAttribute.MAX">
<span class="sig-name descname"><span class="pre">MAX</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccessModeAttribute.MAX:</span> <span class="pre">16&gt;</span></em><a class="headerlink" href="#pygenn.VarAccessModeAttribute.MAX" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccessModeAttribute.READ_ONLY">
<span class="sig-name descname"><span class="pre">READ_ONLY</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccessModeAttribute.READ_ONLY:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pygenn.VarAccessModeAttribute.READ_ONLY" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccessModeAttribute.READ_WRITE">
<span class="sig-name descname"><span class="pre">READ_WRITE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccessModeAttribute.READ_WRITE:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pygenn.VarAccessModeAttribute.READ_WRITE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccessModeAttribute.REDUCE">
<span class="sig-name descname"><span class="pre">REDUCE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccessModeAttribute.REDUCE:</span> <span class="pre">4&gt;</span></em><a class="headerlink" href="#pygenn.VarAccessModeAttribute.REDUCE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarAccessModeAttribute.SUM">
<span class="sig-name descname"><span class="pre">SUM</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarAccessModeAttribute.SUM:</span> <span class="pre">8&gt;</span></em><a class="headerlink" href="#pygenn.VarAccessModeAttribute.SUM" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarAccessModeAttribute.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.VarAccessModeAttribute.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarAccessModeAttribute.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.VarAccessModeAttribute.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.VarLocation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">VarLocation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocation" title="pygenn._genn.VarLocation"><span class="pre">pygenn._genn.VarLocation</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.VarLocation" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Supported combination of VarLocationAttribute</p>
<p>Members:</p>
<blockquote>
<div><p>DEVICE : Variable is only located on device. This can be used to save host memory.</p>
<p>HOST_DEVICE : Variable is located on both host and device. This is the default.</p>
<p>HOST_DEVICE_ZERO_COPY : Variable is shared between host and device using zero copy memory.</p>
</div></blockquote>
<p>This can improve performance if data is frequently copied between host and device
but, on non cache-coherent architectures e.g. Jetson, can also reduce access speed.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarLocation.DEVICE">
<span class="sig-name descname"><span class="pre">DEVICE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarLocation.DEVICE:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pygenn.VarLocation.DEVICE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarLocation.HOST_DEVICE">
<span class="sig-name descname"><span class="pre">HOST_DEVICE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarLocation.HOST_DEVICE:</span> <span class="pre">3&gt;</span></em><a class="headerlink" href="#pygenn.VarLocation.HOST_DEVICE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarLocation.HOST_DEVICE_ZERO_COPY">
<span class="sig-name descname"><span class="pre">HOST_DEVICE_ZERO_COPY</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarLocation.HOST_DEVICE_ZERO_COPY:</span> <span class="pre">7&gt;</span></em><a class="headerlink" href="#pygenn.VarLocation.HOST_DEVICE_ZERO_COPY" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarLocation.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.VarLocation.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarLocation.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.VarLocation.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.VarLocationAttribute">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">VarLocationAttribute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.VarLocationAttribute" title="pygenn._genn.VarLocationAttribute"><span class="pre">pygenn._genn.VarLocationAttribute</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.VarLocationAttribute" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Flags defining attributes of var locations</p>
<p>Members:</p>
<blockquote>
<div><p>HOST : Variable is located on the host</p>
<p>DEVICE : Variable is located on the device</p>
<p>ZERO_COPY : Variable is located in zero-copy memory</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarLocationAttribute.DEVICE">
<span class="sig-name descname"><span class="pre">DEVICE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarLocationAttribute.DEVICE:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pygenn.VarLocationAttribute.DEVICE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarLocationAttribute.HOST">
<span class="sig-name descname"><span class="pre">HOST</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarLocationAttribute.HOST:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pygenn.VarLocationAttribute.HOST" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.VarLocationAttribute.ZERO_COPY">
<span class="sig-name descname"><span class="pre">ZERO_COPY</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;VarLocationAttribute.ZERO_COPY:</span> <span class="pre">4&gt;</span></em><a class="headerlink" href="#pygenn.VarLocationAttribute.ZERO_COPY" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarLocationAttribute.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.VarLocationAttribute.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.VarLocationAttribute.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.VarLocationAttribute.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_current_source_model">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_current_source_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neuron_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">injection_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_current_source_model" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new current source model.
Within the <code class="docutils literal notranslate"><span class="pre">injection_code</span></code> code string, the variables, parameters,
derived parameters, neuron variable references and extra global
parameters defined in this model can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code> which represents a neurons index within a population (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_neurons</span></code> which represents the number of neurons in the population</p></li>
</ul>
<p>Finally, the function <code class="docutils literal notranslate"><span class="pre">injectCurrent(x)</span></code> can be used to inject a current
<code class="docutils literal notranslate"><span class="pre">x</span></code> into the attached neuron. The variable it goes into can be
configured using the <code class="xref py py-attr docutils literal notranslate"><span class="pre">CurrentSource.target_var</span></code>. It defaults to <code class="docutils literal notranslate"><span class="pre">Isyn</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of model variables</p></li>
<li><p><strong>neuron_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to variables
in neuron population current source is attached to</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>injection_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the simulation code
statements to be run every timestep</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of model
extra global parameters</p></li>
</ul>
</dd>
</dl>
<p>For example, we can define a simple current source that
injects uniformly-distributed noise as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">uniform_noise_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_current_source_model</span><span class="p">(</span>
    <span class="s2">&quot;uniform_noise&quot;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;magnitude&quot;</span><span class="p">],</span>
    <span class="n">injection_code</span><span class="o">=</span><span class="s2">&quot;injectCurrent(gennrand_uniform() * magnitude);&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_custom_connectivity_update_model">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_custom_connectivity_update_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_update_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host_update_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_param_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_custom_connectivity_update_model" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new custom connectivity update model.</p>
<p>Within host update code, you have full access to parameters, derived parameters,
extra global parameters and pre and postsynaptic variables. By design you do
not have access to per-synapse variables or variable references and, currently,
you cannot access pre and postsynaptic variable references as there are issues regarding delays.
Each variable has an accompanying push and pull function to copy it to and from the device.
For variables these have no parameters as illustrated in the example in <a class="reference internal" href="../simulating_networks.html#section-pull-push"><span class="std std-ref">Pushing and pulling</span></a>, and for
extra global parameters they have a single parameter specifying the size of the array.
Within the row update code you have full access to parameters, derived parameters,
extra global parameters, presynaptic variables and presynaptic variables references.
Postsynaptic and synaptic variables and variables references can only be accessed
from within one of the <code class="docutils literal notranslate"><span class="pre">for_each_synapse</span></code> loops illustrated below.
Additionally, both the host and row update code cam refer to the following built-in
read-only variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">row_stride</span></code> which represents the maximum number of synapses which each presynaptic neuron can have (this can be increased via <a class="reference internal" href="#pygenn.SynapseGroup.max_connections" title="pygenn.SynapseGroup.max_connections"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseGroup.max_connections</span></code></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pre</span></code> which represents the number of presynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_post</span></code> which represents the number of postsynaptic neurons</p></li>
</ul>
<p>Host code can also access the current number of synapses emanating from each presynaptic
neuron using the <code class="docutils literal notranslate"><span class="pre">row_length</span></code> array whereas, in row-update code, this contains the number of
synapses emanating from the current presynaptic neuron (identified by <code class="docutils literal notranslate"><span class="pre">id_pre</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of per-synapse model variables</p></li>
<li><p><strong>pre_vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of per-presynaptic neuron model variables</p></li>
<li><p><strong>names</strong> (<em>post_vars</em>) – modifiers of per-postsynaptic neuron model variables</p></li>
<li><p><strong>access</strong> (<em>types and optional variable</em>) – modifiers of per-postsynaptic neuron model variables</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to synaptic variables</p></li>
<li><p><strong>pre_neuron_var_refs</strong> – names, types and optional variable access
of references to be assigned to presynaptic
neuron variables</p></li>
<li><p><strong>post_neuron_var_refs</strong> – names, types and optional variable access
of references to be assigned to postsynaptic
neuron variables</p></li>
<li><p><strong>row_update_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the code statements
to be run when custom update is launched</p></li>
<li><p><strong>host_update_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the code statements to be run
on CPU when custom connectivity update is launched</p></li>
<li><p><strong>extra_global_params</strong> – names and types of model
extra global parameters</p></li>
<li><p><strong>extra_global_param_refs</strong> – names and types of extra global
parameter references</p></li>
<li><p><strong>post_vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
<li><p><strong>pre_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
<li><p><strong>post_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
</ul>
</dd>
</dl>
<section id="parallel-synapse-iteration-and-removal">
<h2>Parallel synapse iteration and removal<a class="headerlink" href="#parallel-synapse-iteration-and-removal" title="Permalink to this heading"></a></h2>
<p>The main GPU operation that custom connectivity updates expose is the ability to generate per-presynaptic neuron update code. This can be used to implement a very simple model which removes ‘diagonals’ from the connectivity matrix:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">remove_diagonal_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_connectivity_update_model</span><span class="p">(</span>
    <span class="s2">&quot;remove_diagonal&quot;</span><span class="p">,</span>
    <span class="n">row_update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for_each_synapse {</span>
<span class="sd">            if(id_post == id_pre) {</span>
<span class="sd">                remove_synapse();</span>
<span class="sd">                break;</span>
<span class="sd">            }</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="parallel-synapse-creation">
<h2>Parallel synapse creation<a class="headerlink" href="#parallel-synapse-creation" title="Permalink to this heading"></a></h2>
<p>Similarly you could implement a custom connectivity model which adds diagonals back into the connection matrix like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">add_diagonal_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_connectivity_update_model</span><span class="p">(</span>
    <span class="s2">&quot;add_diagonal&quot;</span><span class="p">,</span>
    <span class="n">row_update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add_synapse(id_pre);</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>One important issue here is that lots of other parts of the model (e.g. other custom connectivity updates or custom weight updates) <em>might</em> have state variables ‘attached’ to the same connectivity that the custom update is modifying. GeNN will automatically detect this and add and shuffle all these variables around accordingly which is fine for removing synapses but has no way of knowing what value to add synapses with. If you want new synapses to be created with state variables initialised to values other than zero, you need to use variables references to hook them to the custom connectivity update. For example, if you wanted to be able to provide weights for your new synapse, you could update the previous example model like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">add_diagonal_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_connectivity_update_model</span><span class="p">(</span>
    <span class="s2">&quot;add_diagonal&quot;</span><span class="p">,</span>
    <span class="n">var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>
    <span class="n">row_update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add_synapse(id_pre, 1.0);</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="host-updates">
<h2>Host updates<a class="headerlink" href="#host-updates" title="Permalink to this heading"></a></h2>
<p>Some common connectivity update scenarios involve some computation which can’t be easily parallelized. If, for example you wanted to determine which elements on each row you wanted to remove on the host, you can include <code class="docutils literal notranslate"><span class="pre">host_update_code</span></code> which gets run before the row update code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">remove_diagonal_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_connectivity_update_model</span><span class="p">(</span>
    <span class="s2">&quot;remove_diagonal&quot;</span><span class="p">,</span>
    <span class="n">pre_var_name_types</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;postInd&quot;</span><span class="p">,</span> <span class="s2">&quot;unsigned int&quot;</span><span class="p">)],</span>
    <span class="n">row_update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for_each_synapse {</span>
<span class="sd">            if(id_post == postInd) {</span>
<span class="sd">                remove_synapse();</span>
<span class="sd">                break;</span>
<span class="sd">            }</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">host_update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for(unsigned int i = 0; i &lt; num_pre; i++) {</span>
<span class="sd">           postInd[i] = i;</span>
<span class="sd">        }</span>
<span class="sd">        pushpostIndToDevice();</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_custom_update_model">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_custom_update_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_param_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_custom_update_model" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new custom update model.
Within the <code class="docutils literal notranslate"><span class="pre">update_code</span></code> code string, the variables, parameters,
derived parameters, variable references, extra global parameters
and extra global parameter references defined in this model can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
</ul>
<blockquote>
<div><p>And, if a custom update using this model is attached to per-neuron variables:</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code> which represents a neurons index within a population (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_neurons</span></code> which represents the number of neurons in the population</p></li>
</ul>
<p>or, to per-synapse variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id_pre</span></code> which represents the index of the presynaptic neuron (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id_post</span></code> which represents the index of the postsynaptic neuron (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pre</span></code> which represents the number of presynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_post</span></code> which represents the number of postsynaptic neurons</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.CustomUpdateVarAccess" title="pygenn._genn.CustomUpdateVarAccess"><em>CustomUpdateVarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of model variables</p></li>
<li><p><strong>var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to variables
in population(s) custom update is attached to</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>update_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the code statements
to be run when custom update is launched</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of model
extra global parameters</p></li>
<li><p><strong>extra_global_param_refs</strong> – names and types of extra global
parameter references</p></li>
</ul>
</dd>
</dl>
<p>For example, we can define a custom update which will set a referenced variable to the value of a custom update model state variable:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">reset_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_update_model</span><span class="p">(</span>
    <span class="s2">&quot;reset&quot;</span><span class="p">,</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">CustomUpdateVarAccess</span><span class="o">.</span><span class="n">READ_ONLY</span><span class="p">)],</span>
    <span class="n">var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">VarAccessMode</span><span class="o">.</span><span class="n">READ_WRITE</span><span class="p">)],</span>
    <span class="n">update_code</span><span class="o">=</span><span class="s2">&quot;r = v;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>When used in a model with batch size &gt; 1, whether custom updates of this sort are batched or not depends on the variables their references point to.
If any referenced variables have <a class="reference internal" href="#pygenn.VarAccess.READ_ONLY_DUPLICATE" title="pygenn.VarAccess.READ_ONLY_DUPLICATE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccess.READ_ONLY_DUPLICATE</span></code></a> or <a class="reference internal" href="#pygenn.VarAccess.READ_WRITE" title="pygenn.VarAccess.READ_WRITE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccess.READ_WRITE</span></code></a> access modes, then the update will be batched
and any variables associated with the custom update with <a class="reference internal" href="#pygenn.VarAccess.READ_ONLY_DUPLICATE" title="pygenn.VarAccess.READ_ONLY_DUPLICATE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccess.READ_ONLY_DUPLICATE</span></code></a> or <a class="reference internal" href="#pygenn.VarAccess.READ_WRITE" title="pygenn.VarAccess.READ_WRITE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccess.READ_WRITE</span></code></a> access modes will be duplicated across the batches.</p>
<section id="batch-reduction">
<h2>Batch reduction<a class="headerlink" href="#batch-reduction" title="Permalink to this heading"></a></h2>
<p>As well as the standard variable access modes described previously, custom updates support variables with ‘batch reduction’ access modes
such as <a class="reference internal" href="#pygenn.CustomUpdateVarAccess.REDUCE_BATCH_SUM" title="pygenn.CustomUpdateVarAccess.REDUCE_BATCH_SUM"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CustomUpdateVarAccess.REDUCE_BATCH_SUM</span></code></a> and <a class="reference internal" href="#pygenn.CustomUpdateVarAccess.REDUCE_BATCH_MAX" title="pygenn.CustomUpdateVarAccess.REDUCE_BATCH_MAX"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CustomUpdateVarAccess.REDUCE_BATCH_MAX</span></code></a>.
These access modes allow values read from variables duplicated across batches to be reduced into variables that are shared across batches.
For example, in a gradient-based learning scenario, a model like this could be used to sum gradients from across all batches so they can be used as the input to a learning rule operating on shared synaptic weights:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">reduce_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_update_model</span><span class="p">(</span>
    <span class="s2">&quot;gradient_batch_reduce&quot;</span><span class="p">,</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;reducedGradient&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">CustomUpdateVarAccess</span><span class="o">.</span><span class="n">REDUCE_BATCH_SUM</span><span class="p">)],</span>
    <span class="n">var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">VarAccessMode</span><span class="o">.</span><span class="n">READ_ONLY</span><span class="p">)],</span>
    <span class="n">update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reducedGradient = gradient;</span>
<span class="sd">        gradient = 0;</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Batch reductions can also be performed into variable references with
the <a class="reference internal" href="#pygenn.VarAccessMode.REDUCE_SUM" title="pygenn.VarAccessMode.REDUCE_SUM"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccessMode.REDUCE_SUM</span></code></a> or <a class="reference internal" href="#pygenn.VarAccessMode.REDUCE_MAX" title="pygenn.VarAccessMode.REDUCE_MAX"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccessMode.REDUCE_MAX</span></code></a> access modes.</p>
</section>
<section id="neuron-reduction">
<h2>Neuron reduction<a class="headerlink" href="#neuron-reduction" title="Permalink to this heading"></a></h2>
<p>Similarly to the batch reduction modes discussed previously, custom updates also support variables with several ‘neuron reduction’ access modes
such as <a class="reference internal" href="#pygenn.CustomUpdateVarAccess.REDUCE_NEURON_SUM" title="pygenn.CustomUpdateVarAccess.REDUCE_NEURON_SUM"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CustomUpdateVarAccess.REDUCE_NEURON_SUM</span></code></a> and <a class="reference internal" href="#pygenn.CustomUpdateVarAccess.REDUCE_NEURON_MAX" title="pygenn.CustomUpdateVarAccess.REDUCE_NEURON_MAX"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CustomUpdateVarAccess.REDUCE_NEURON_MAX</span></code></a>.</p>
<p>These access modes allow values read from per-neuron variables to be reduced into variables that are shared across neurons.
For example, a model like this could be used to calculate the maximum value of a state variable in a population of neurons:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">reduce_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_update_model</span><span class="p">(</span>
    <span class="s2">&quot;neuron_reduce&quot;</span><span class="p">,</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;reduction&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">CustomUpdateVarAccess</span><span class="o">.</span><span class="n">REDUCE_NEURON_SUM</span><span class="p">)],</span>
    <span class="n">var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">VarAccessMode</span><span class="o">.</span><span class="n">READ_ONLY</span><span class="p">)],</span>
    <span class="n">update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reduction = source;</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, like batch reductions, neuron reductions can also be performed into variable references with
the <a class="reference internal" href="#pygenn.VarAccessMode.REDUCE_SUM" title="pygenn.VarAccessMode.REDUCE_SUM"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccessMode.REDUCE_SUM</span></code></a> or <a class="reference internal" href="#pygenn.VarAccessMode.REDUCE_MAX" title="pygenn.VarAccessMode.REDUCE_MAX"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccessMode.REDUCE_MAX</span></code></a> access modes.</p>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_egp_ref">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_egp_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_egp_ref" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>create_egp_ref(arg0: GeNN::NeuronGroup, arg1: str) -&gt; GeNN::Models::EGPReference</p></li>
</ol>
<p>Creates a reference to a neuron group extra global parameter.</p>
<ol class="arabic simple" start="2">
<li><p>create_egp_ref(arg0: GeNN::CurrentSource, arg1: str) -&gt; GeNN::Models::EGPReference</p></li>
</ol>
<p>Creates a reference to a current source extra global parameter.</p>
<ol class="arabic simple" start="3">
<li><p>create_egp_ref(arg0: GeNN::CustomUpdate, arg1: str) -&gt; GeNN::Models::EGPReference</p></li>
</ol>
<p>Creates a reference to a custom update extra global parameter.</p>
<ol class="arabic simple" start="4">
<li><p>create_egp_ref(arg0: GeNN::CustomUpdateWU, arg1: str) -&gt; GeNN::Models::EGPReference</p></li>
</ol>
<p>Creates a reference to a custom weight update extra global parameter.</p>
<ol class="arabic simple" start="5">
<li><p>create_egp_ref(arg0: GeNN::CustomConnectivityUpdate, arg1: str) -&gt; GeNN::Models::EGPReference</p></li>
</ol>
<p>Creates a reference to a custom connectivity update extra global parameter.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_neuron_model">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_neuron_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_condition_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reset_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_input_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auto_refractory_required</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_neuron_model" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new neuron model.
Within all of the code strings, the variables, parameters,
derived parameters, additional input variables and extra global
parameters defined in this model can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Isyn</span></code> which represents the total incoming synaptic input.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code> which represents a neurons index within a population (starting from zero).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_neurons</span></code> which represents the number of neurons in the population.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of model variables</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>sim_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the simulation code
statements to be run every timestep</p></li>
<li><p><strong>threshold_condition_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing a threshold condition
expression to test whether a spike
should be emitted</p></li>
<li><p><strong>reset_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the reset code
statements to run after emitting a spike</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of model
extra global parameters</p></li>
<li><p><strong>additional_input_vars</strong> – list of tuples with names and types as
strings and initial values of additional
local input variables</p></li>
<li><p><strong>auto_refractory_required</strong> (<em>bool</em>) – does this model require auto-refractory
logic to be generated?</p></li>
</ul>
</dd>
</dl>
<p>For example, we can define a leaky integrator <span class="math notranslate nohighlight">\(\tau\frac{dV}{dt}= -V + I_{{\rm syn}}\)</span> solved using Euler’s method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">leaky_integrator_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_neuron_model</span><span class="p">(</span>
    <span class="s2">&quot;leaky_integrator&quot;</span><span class="p">,</span>

    <span class="n">sim_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        V += (-V + Isyn) * (dt / tau);</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">threshold_condition_code</span><span class="o">=</span><span class="s2">&quot;V &gt;= 1.0&quot;</span><span class="p">,</span>
    <span class="n">reset_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        V = 0.0;</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>

    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">],</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">VarAccess</span><span class="o">.</span><span class="n">READ_WRITE</span><span class="p">)])</span>
</pre></div>
</div>
<section id="additional-input-variables">
<h2>Additional input variables<a class="headerlink" href="#additional-input-variables" title="Permalink to this heading"></a></h2>
<p>Normally, neuron models receive the linear sum of the inputs coming from all of their synaptic inputs through the <code class="docutils literal notranslate"><span class="pre">Isyn</span></code> variable.
However neuron models can define additional input variables, allowing input from different synaptic inputs to be combined non-linearly.
For example, if we wanted our leaky integrator to operate on the the product of two input currents, we could modify our model as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">additional_input_vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;Isyn2&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)],</span>
<span class="n">sim_code</span><span class="o">=</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    const scalar input = Isyn * Isyn2;</span>
<span class="sd">    sim_code=&quot;V += (-V + input) * (dt / tau);</span>
<span class="sd">    &quot;&quot;&quot;</span><span class="p">,</span>
<span class="o">...</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_post_var_ref">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_post_var_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg0:</span> <span class="pre">GeNN::CustomConnectivityUpdate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1:</span> <span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">GeNN::Models::VarReference</span></span></span><a class="headerlink" href="#pygenn.create_post_var_ref" title="Permalink to this definition"></a></dt>
<dd><p>Creates a reference to a postsynaptic custom connectivity update variable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_postsynaptic_model">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_postsynaptic_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neuron_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_postsynaptic_model" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new postsynaptic update model.
Within all of the code strings, the variables, parameters,
derived parameters and extra global parameters defined in this model
can all be referred to by name. Additionally, the code may refer to the
following built-in read-only variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code> which represents a neurons index within a population (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_neurons</span></code> which represents the number of neurons in the population</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inSyn</span></code> which contains the summed input received from the weight update model through <code class="docutils literal notranslate"><span class="pre">addToPost()</span></code> or <code class="docutils literal notranslate"><span class="pre">addToPostDelay()</span></code></p></li>
</ul>
<p>Finally, the function <code class="docutils literal notranslate"><span class="pre">injectCurrent(x)</span></code> can be used to inject a current
<code class="docutils literal notranslate"><span class="pre">x</span></code> into the postsynaptic neuron. The variable it goes into can be
configured using the <a class="reference internal" href="#pygenn.SynapseGroup.post_target_var" title="pygenn.SynapseGroup.post_target_var"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseGroup.post_target_var</span></code></a>. By default it targets <code class="docutils literal notranslate"><span class="pre">Isyn</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> – names, types and optional variable access
modifiers of model variables</p></li>
<li><p><strong>neuron_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to postsynaptic
neuron variables</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>sim_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the simulation code
statements to be run every timestep</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of model
extra global parameters</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_pre_var_ref">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_pre_var_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg0:</span> <span class="pre">GeNN::CustomConnectivityUpdate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1:</span> <span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">GeNN::Models::VarReference</span></span></span><a class="headerlink" href="#pygenn.create_pre_var_ref" title="Permalink to this definition"></a></dt>
<dd><p>Creates a reference to a presynaptic custom connectivity update variable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_psm_egp_ref">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_psm_egp_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg0:</span> <span class="pre">GeNN::SynapseGroup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1:</span> <span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">GeNN::Models::EGPReference</span></span></span><a class="headerlink" href="#pygenn.create_psm_egp_ref" title="Permalink to this definition"></a></dt>
<dd><p>Creates a reference to a postsynaptic model extra global parameter.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_psm_var_ref">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_psm_var_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg0:</span> <span class="pre">GeNN::SynapseGroup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1:</span> <span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">GeNN::Models::VarReference</span></span></span><a class="headerlink" href="#pygenn.create_psm_var_ref" title="Permalink to this definition"></a></dt>
<dd><p>Creates a reference to a postsynaptic model variable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_sparse_connect_init_snippet">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_sparse_connect_init_snippet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_build_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_build_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_max_row_len_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_max_col_len_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_kernel_size_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_sparse_connect_init_snippet" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new sparse connectivity initialisation snippet.
Within the code strings, the parameters, derived parameters and
extra global parameters defined in this snippet can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pre</span></code> which represents the number of presynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_post</span></code> which represents the number of postsynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thread</span></code> when some procedural connectivity is used with multiple
threads per presynaptic neuron, represents the index of the current thread</p></li>
</ul>
<p>and, in <code class="docutils literal notranslate"><span class="pre">row_build_code</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id_pre</span></code> represents the index of the presynaptic neuron (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id_post_begin</span></code> when some procedural connectivity is used with multiple
threads per presynaptic neuron, represents the index of the first postsynaptic neuron to connect.</p></li>
</ul>
<p>and, in <code class="docutils literal notranslate"><span class="pre">col_build_code</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id_post</span></code> which represents the index of the postsynaptic neuron (starting from zero).</p></li>
</ul>
<p>Finally, the function <code class="docutils literal notranslate"><span class="pre">addSynapse(x)</span></code> can be used to add a new synapse to the connectivity
where, in <code class="docutils literal notranslate"><span class="pre">row_build_code</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is the index of the postsynaptic neuron to connect <code class="docutils literal notranslate"><span class="pre">id_pre</span></code> to
and, in <code class="docutils literal notranslate"><span class="pre">col_build_code</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is the index of the presynaptic neuron to connect to <code class="docutils literal notranslate"><span class="pre">id_post</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the snippet (only for debugging)</p></li>
<li><p><strong>params</strong> – name and optional types of model parameters</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from paramss</p></li>
<li><p><strong>row_build_code</strong> (<em>str</em><em> | </em><em>None</em>) – code for building connectivity row by row</p></li>
<li><p><strong>col_build_code</strong> (<em>str</em><em> | </em><em>None</em>) – code for building connectivity column by column</p></li>
<li><p><strong>calc_max_row_len_func</strong> (<em>Callable</em><em> | </em><em>None</em>) – used to calculate the maximum
row length of the synaptic matrix created using this snippet</p></li>
<li><p><strong>calc_max_col_len_func</strong> (<em>Callable</em><em> | </em><em>None</em>) – used to calculate the maximum
column length of the synaptic matrix created using this snippet</p></li>
<li><p><strong>calc_kernel_size_func</strong> (<em>Callable</em><em> | </em><em>None</em>) – used to calculate the size of the kernel if snippet requires one</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of snippet extra global parameters</p></li>
<li><p><strong>param_names</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
</ul>
</dd>
</dl>
<p>For example, if we wanted to define a snippet to initialise connectivity where each
presynaptic neuron targets a fixed number of postsynaptic neurons, sampled uniformly
with replacement, we could define a snippet as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">binom</span>

<span class="n">fixed_number_post</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_sparse_connect_init_snippet</span><span class="p">(</span>
    <span class="s2">&quot;fixed_number_post&quot;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;num&quot;</span><span class="p">,</span> <span class="s2">&quot;unsigned int&quot;</span><span class="p">)],</span>
    <span class="n">row_build_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for(unsigned int c = num; c != 0; c--) {</span>
<span class="sd">            const unsigned int idPost = gennrand() % num_post;</span>
<span class="sd">            addSynapse(idPost + id_post_begin);</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">calc_max_row_len_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">num_pre</span><span class="p">,</span> <span class="n">num_post</span><span class="p">,</span> <span class="n">pars</span><span class="p">:</span> <span class="n">pars</span><span class="p">[</span><span class="s2">&quot;num&quot;</span><span class="p">],</span>
    <span class="n">calc_max_col_len_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">num_pre</span><span class="p">,</span> <span class="n">num_post</span><span class="p">,</span> <span class="n">pars</span><span class="p">:</span> <span class="n">binom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.9999</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_post</span><span class="p">),</span>
                                                                    <span class="n">pars</span><span class="p">[</span><span class="s2">&quot;num&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_pre</span><span class="p">,</span>
                                                                    <span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_post</span><span class="p">))</span>
</pre></div>
</div>
<p>For full details of how maximum column lengths are calculated, you should refer to our paper <a class="reference internal" href="../bibliography.html#knight2018" id="id1"><span>[Knight2018]</span></a> but,
in short, the number of connections that end up in a column are distributed binomially with <span class="math notranslate nohighlight">\(n=\text{num}\)</span> and <span class="math notranslate nohighlight">\(p=\frac{1}{\text{num_post}}\)</span>
Therefore, we can calculate the maximum column length by looking at the inverse cummulative distribution function (CDF) for the binomial distribution,
looking at the point in the inverse CDF where there is a 0.9999 chance of the bound being correct when drawing synapses from <code class="docutils literal notranslate"><span class="pre">num_post</span></code> columns.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_toeplitz_connect_init_snippet">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_toeplitz_connect_init_snippet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal_build_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_max_row_len_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_kernel_size_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_toeplitz_connect_init_snippet" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new Toeplitz connectivity initialisation snippet.
Each <em>diagonal</em> of Toeplitz connectivity is initialised independently by running the
snippet of code specified using the <code class="docutils literal notranslate"><span class="pre">diagonal_build_code</span></code>.
Within the code strings, the parameters, derived parameters and
extra global parameters defined in this snippet can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pre</span></code> which represents the number of presynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_post</span></code> which represents the number of postsynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id_diag</span></code> when some procedural connectivity is used with multiple threads</p></li>
</ul>
<p>Additionally, the function <code class="docutils literal notranslate"><span class="pre">addSynapse(id_post,</span> <span class="pre">id_kern_0,</span> <span class="pre">id_kern_1,</span> <span class="pre">...,</span> <span class="pre">id_kern_N)</span></code>
can be used to generate a new synapse to postsynaptic neuron <code class="docutils literal notranslate"><span class="pre">id_post</span></code> using
N-dimensional kernel variables indexed with <code class="docutils literal notranslate"><span class="pre">id_kern_0,</span> <span class="pre">id_kern_1,</span> <span class="pre">...,</span> <span class="pre">id_kern_N</span></code>.
Finally the <code class="docutils literal notranslate"><span class="pre">for_each_synapse{}</span></code> construct can be used to loop through incoming spikes
and, inside this, <code class="docutils literal notranslate"><span class="pre">id_pre</span></code> will represent the index of the spiking presynaptic neuron.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the snippet (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from paramss</p></li>
<li><p><strong>diagonal_build_code</strong> (<em>str</em><em> | </em><em>None</em>) – code for building connectivity row by row</p></li>
<li><p><strong>calc_max_row_len_func</strong> (<em>Callable</em><em> | </em><em>None</em>) – used to calculate the maximum
row length of synaptic matrix created using this snippet</p></li>
<li><p><strong>calc_kernel_size_func</strong> (<em>Callable</em><em> | </em><em>None</em>) – used to calculate the size of the kernel</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of snippet extra global parameters</p></li>
</ul>
</dd>
</dl>
<p>For example, the following Toeplitz connectivity initialisation snippet could be used to
convolve a <span class="math notranslate nohighlight">\(\text{kern_dim} \times \text{kern_dim}\)</span> square kernel with the spikes from a population of <span class="math notranslate nohighlight">\(\text{pop_dim} \times \text{pop_dim}\)</span> neurons.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">simple_conv2d_model</span> <span class="o">=</span> <span class="n">pynn</span><span class="o">.</span><span class="n">create_toeplitz_connect_init_snippet</span><span class="p">(</span>
    <span class="s2">&quot;simple_conv2d&quot;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;kern_size&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pop_dim&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">)],</span>
    <span class="n">diagonal_build_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        const int kernRow = id_diag / kern_dim;</span>
<span class="sd">        const int kernCol = id_diag % kern_dim;</span>

<span class="sd">        for_each_synapse {</span>
<span class="sd">            const int preRow = id_pre / pop_dim;</span>
<span class="sd">            const int preCol = id_pre % pop_dim;</span>
<span class="sd">            // If we haven&#39;t gone off edge of output</span>
<span class="sd">            const int postRow = preRow + kernRow - 1;</span>
<span class="sd">            const int postCol = preCol + kernCol - 1;</span>
<span class="sd">            if(postRow &gt;= 0 &amp;&amp; postCol &gt;= 0 &amp;&amp; postRow &lt; pop_dim &amp;&amp; postCol &lt; pop_dim) {</span>
<span class="sd">                // Calculate postsynaptic index</span>
<span class="sd">                const int postInd = (postRow * pop_dim) + postCol;</span>
<span class="sd">                addSynapse(postInd,  kernRow, kernCol);</span>
<span class="sd">            }</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>

    <span class="n">calc_max_row_len_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">num_pre</span><span class="p">,</span> <span class="n">num_post</span><span class="p">,</span> <span class="n">pars</span><span class="p">:</span> <span class="n">pars</span><span class="p">[</span><span class="s2">&quot;kern_size&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">pars</span><span class="p">[</span><span class="s2">&quot;kern_size&quot;</span><span class="p">],</span>
    <span class="n">calc_kernel_size_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pars</span><span class="p">:</span> <span class="p">[</span><span class="n">pars</span><span class="p">[</span><span class="s2">&quot;kern_size&quot;</span><span class="p">],</span> <span class="n">pars</span><span class="p">[</span><span class="s2">&quot;kern_size&quot;</span><span class="p">]])</span>
</pre></div>
</div>
<p>For full details of how convolution-like connectivity is expressed in this way, please see our paper <a class="reference internal" href="../bibliography.html#turner2022" id="id2"><span>[Turner2022]</span></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_var_init_snippet">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_var_init_snippet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_init_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_var_init_snippet" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new variable initialisation snippet.
Within the <code class="docutils literal notranslate"><span class="pre">var_init_code</span></code>, the parameters, derived parameters and
extra global parameters defined in this snippet can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
</ul>
<p>And, if the snippet is used to initialise a per-neuron variable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code> which represents a neurons index within a population (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_neurons</span></code> which represents the number of neurons in the population</p></li>
</ul>
<p>or, a per-synapse variable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id_pre</span></code> which represents the index of the presynaptic neuron (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id_post</span></code> which represents the index of the postsynaptic neuron (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pre</span></code> which represents the number of presynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_post</span></code> which represents the number of postsynaptic neurons</p></li>
</ul>
<p>Finally, the variable being initialised is represented by
the write-only <code class="docutils literal notranslate"><span class="pre">value</span></code> variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new model (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from paramss</p></li>
<li><p><strong>var_init_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the code statements
required to initialise the variable</p></li>
<li><p><strong>extra_global_params</strong> – names and types of model
extra global parameters</p></li>
</ul>
</dd>
</dl>
<p>For example, if we wanted to define a snippet to initialise variables by sampling from a normal distribution,
redrawing if the value is negative (which could be useful to ensure delays remain causal):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">normal_positive_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_var_init_snippet</span><span class="p">(</span>
    <span class="s1">&#39;normal_positive&#39;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">],</span>
    <span class="n">var_init_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        scalar normal;</span>
<span class="sd">        do {</span>
<span class="sd">            normal = mean + (gennrand_normal() * sd);</span>
<span class="sd">        } while (normal &lt; 0.0);</span>
<span class="sd">        value = normal;</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_var_ref">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_var_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_var_ref" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>create_var_ref(arg0: GeNN::NeuronGroup, arg1: str) -&gt; GeNN::Models::VarReference</p></li>
</ol>
<p>Creates a reference to a neuron group variable.</p>
<ol class="arabic simple" start="2">
<li><p>create_var_ref(arg0: GeNN::CurrentSource, arg1: str) -&gt; GeNN::Models::VarReference</p></li>
</ol>
<p>Creates a reference to a current source variable.</p>
<ol class="arabic simple" start="3">
<li><p>create_var_ref(arg0: GeNN::CustomUpdate, arg1: str) -&gt; GeNN::Models::VarReference</p></li>
</ol>
<p>Creates a reference to a custom update variable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_weight_update_model">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_weight_update_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_vars=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_</span> <span class="pre">post_vars=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_</span> <span class="pre">pre_neuron_var_refs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_neuron_var_refs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_spike_syn_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_event_syn_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_event_syn_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_spike_syn_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synapse_dynamics_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_</span> <span class="pre">post_</span> <span class="pre">pre_spike_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_spike_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_dynamics_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_dynamics_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_weight_update_model" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new weight update model.
GeNN operates on the assumption that the postsynaptic output of the synapses are added linearly at the postsynaptic neuron.
Within all of the synaptic code strings (<code class="docutils literal notranslate"><span class="pre">pre_spike_syn_code</span></code>, <code class="docutils literal notranslate"><span class="pre">pre_event_syn_code</span></code>,
<code class="docutils literal notranslate"><span class="pre">post_event_syn_code</span></code>, <code class="docutils literal notranslate"><span class="pre">post_spike_syn_code</span></code> and <code class="docutils literal notranslate"><span class="pre">synapse_dynamics_code</span></code> ) these currents are delivered using the <code class="docutils literal notranslate"><span class="pre">addToPost(inc)</span></code> function.
For example,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pre_spike_syn_code</span><span class="o">=</span><span class="s2">&quot;addToPost(inc);&quot;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">inc</span></code> is the amount to add to the postsynapse model’s <code class="docutils literal notranslate"><span class="pre">inSyn</span></code> variable for each pre-synaptic spike.
Dendritic delays can also be inserted between the synapse and the postsynaptic neuron by using the <code class="docutils literal notranslate"><span class="pre">addToPostDelay(inc,</span> <span class="pre">delay)</span></code> function.
For example,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pre_spike_syn_code</span><span class="o">=</span><span class="s2">&quot;addToPostDelay(inc, delay);&quot;</span>
</pre></div>
</div>
<p>where, once again, <code class="docutils literal notranslate"><span class="pre">inc</span></code> is the amount to add to the postsynaptic neuron’s <code class="docutils literal notranslate"><span class="pre">inSyn</span></code> variable and <code class="docutils literal notranslate"><span class="pre">delay</span></code> is the length of the dendritic delay in timesteps.
By implementing <code class="docutils literal notranslate"><span class="pre">delay</span></code> as a weight update model variable, heterogeneous synaptic delays can be implemented.
For an example, see WeightUpdateModels::StaticPulseDendriticDelay for a simple synapse update model with heterogeneous dendritic delays.</p>
<p>When using dendritic delays, the <em>maximum</em> dendritic delay for a synapse populations must be specified via the
<a class="reference internal" href="#pygenn.SynapseGroup.max_dendritic_delay_timesteps" title="pygenn.SynapseGroup.max_dendritic_delay_timesteps"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseGroup.max_dendritic_delay_timesteps</span></code></a> property. One can also define synaptic effects that occur in the reverse direction,
i.e. terms that are added to a target variable in the _presynaptic_ neuron using the <code class="docutils literal notranslate"><span class="pre">addToPre(inc)</span></code> function. For example,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pre_spike_syn_code</span><span class="o">=</span><span class="s2">&quot;addToPre(inc * V_post);&quot;</span>
</pre></div>
</div>
<p>would add terms <code class="docutils literal notranslate"><span class="pre">inc</span> <span class="pre">*</span> <span class="pre">V_post</span></code> to for each <em>outgoing</em> synapse of a presynaptic neuron.
Similar to postsynaptic models, by default these inputs are accumulated in <code class="docutils literal notranslate"><span class="pre">Isyn</span></code> in the presynaptic
neuron but they can also be directed to additional input variables by setting the
<a class="reference internal" href="#pygenn.SynapseGroup.pre_target_var" title="pygenn.SynapseGroup.pre_target_var"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseGroup.pre_target_var</span></code></a> property. Unlike for normal forward synaptic
actions, reverse synaptic actions with <code class="docutils literal notranslate"><span class="pre">addToPre(inc)</span></code> are not modulated through
a post-synaptic model but added directly into the indicated presynaptic target input variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of per-synapse model variables</p></li>
<li><p><strong>pre_vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of per-presynaptic neuron model variables</p></li>
<li><p><strong>names</strong> (<em>post_vars</em>) – modifiers of per-postsynaptic neuron model variables</p></li>
<li><p><strong>access</strong> (<em>types and optional variable</em>) – modifiers of per-postsynaptic neuron model variables</p></li>
<li><p><strong>pre_neuron_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to presynaptic
neuron variables</p></li>
<li><p><strong>post_neuron_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to postsynaptic
neuron variables</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>pre_spike_syn_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the presynaptic spike code</p></li>
<li><p><strong>pre_event_syn_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the presynaptic event code</p></li>
<li><p><strong>post_event_syn_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the postsynaptic event code</p></li>
<li><p><strong>post_spike_syn_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the postsynaptic spike code</p></li>
<li><p><strong>synapse_dynamics_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the synapse dynamics code</p></li>
<li><p><strong>pre_event_threshold_condition_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the presynaptic event threshold
condition code</p></li>
<li><p><strong>post_event_threshold_condition_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the postsynaptic event threshold
condition code</p></li>
<li><p><strong>pre_spike_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the code run once per
spiking presynaptic neuron. Only
presynaptic variables and
variable references can be
referenced from this code.</p></li>
<li><p><strong>post_spike_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the code run once per
spiking postsynaptic neuron</p></li>
<li><p><strong>pre_dynamics_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the code run every
timestep on presynaptic neuron.
Only presynaptic variables and
variable references can be
referenced from this code.</p></li>
<li><p><strong>post_dynamics_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the code run every
timestep on postsynaptic neuron.
Only postsynaptic variables and
variable references can be
referenced from this code.</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of model
extra global parameters</p></li>
<li><p><strong>post_vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
</ul>
</dd>
</dl>
<p>For example, we can define a simple additive STDP rule with
nearest-neighbour spike pairing and the following time-dependence (equivalent to <a class="reference internal" href="#pygenn.weight_update_models.STDP" title="pygenn.weight_update_models.STDP"><code class="xref py py-func docutils literal notranslate"><span class="pre">weight_update_models.STDP()</span></code></a>):</p>
<div class="math notranslate nohighlight">
\[\begin{split}\Delta w_{ij} &amp; =             \begin{cases}
        A_{+}\exp\left(-\frac{\Delta t}{\tau_{+}}\right) &amp; if\, \Delta t&gt;0\\
        A_{-}\exp\left(\frac{\Delta t}{\tau_{-}}\right) &amp; if\, \Delta t\leq0
    \end{cases}\end{split}\]</div>
<p>in a fully event-driven manner as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">stdp_additive_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_weight_update_model</span><span class="p">(</span>
    <span class="s2">&quot;stdp_additive&quot;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;tauPlus&quot;</span><span class="p">,</span> <span class="s2">&quot;tauMinus&quot;</span><span class="p">,</span> <span class="s2">&quot;aPlus&quot;</span><span class="p">,</span> <span class="s2">&quot;aMinus&quot;</span><span class="p">,</span> <span class="s2">&quot;wMin&quot;</span><span class="p">,</span> <span class="s2">&quot;wMax&quot;</span><span class="p">],</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>

    <span class="n">pre_spike_syn_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        addToPost(g);</span>
<span class="sd">        const scalar dt = t - st_post;</span>
<span class="sd">        if (dt &gt; 0) {</span>
<span class="sd">            const scalar timing = exp(-dt / tauMinus);</span>
<span class="sd">            const scalar newWeight = g - (Aminus * timing);</span>
<span class="sd">            g = fmax(Wmin, fmin(Wmax, newWeight));</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">post_spike_syn_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        const scalar dt = t - st_pre;</span>
<span class="sd">        if (dt &gt; 0) {</span>
<span class="sd">            const scalar timing = exp(-dt / tauPlus);</span>
<span class="sd">            const scalar newWeight = g + (Aplus * timing);</span>
<span class="sd">            g = fmax(Wmin, fmin(Wmax, newWeight));</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<section id="pre-and-postsynaptic-dynamics">
<h2>Pre and postsynaptic dynamics<a class="headerlink" href="#pre-and-postsynaptic-dynamics" title="Permalink to this heading"></a></h2>
<p>The memory required for synapse variables and the computational cost of updating them tends to grow with <span class="math notranslate nohighlight">\(O(N^2)\)</span> with the number of neurons.
Therefore, if it is possible, implementing synapse variables on a per-neuron rather than per-synapse basis is a good idea.
The <code class="docutils literal notranslate"><span class="pre">pre_var_name_types</span></code> and <code class="docutils literal notranslate"><span class="pre">post_var_name_types</span></code> keyword arguments are used to define any pre or postsynaptic state variables.
For example, using pre and postsynaptic variables, our event-driven STDP rule can be extended to use all-to-all spike pairing using pre and postsynaptic <em>trace</em> variables <a class="reference internal" href="../bibliography.html#morrison2008" id="id3"><span>[Morrison2008]</span></a> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">stdp_additive_2_model</span> <span class="o">=</span> <span class="n">genn_model</span><span class="o">.</span><span class="n">create_custom_weight_update_class</span><span class="p">(</span>
    <span class="s2">&quot;stdp_additive_2&quot;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;tauPlus&quot;</span><span class="p">,</span> <span class="s2">&quot;tauMinus&quot;</span><span class="p">,</span> <span class="s2">&quot;aPlus&quot;</span><span class="p">,</span> <span class="s2">&quot;aMinus&quot;</span><span class="p">,</span> <span class="s2">&quot;wMin&quot;</span><span class="p">,</span> <span class="s2">&quot;wMax&quot;</span><span class="p">],</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>
    <span class="n">pre_vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;preTrace&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>
    <span class="n">post_vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;postTrace&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>

    <span class="n">pre_spike_syn_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        addToPost(g);</span>
<span class="sd">        const scalar dt = t - st_post;</span>
<span class="sd">        if(dt &gt; 0) {</span>
<span class="sd">            const scalar newWeight = g - (aMinus * postTrace);</span>
<span class="sd">            g = fmin(wMax, fmax(wMin, newWeight));</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">post_spike_syn_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        const scalar dt = t - st_pre;</span>
<span class="sd">        if(dt &gt; 0) {</span>
<span class="sd">            const scalar newWeight = g + (aPlus * preTrace);</span>
<span class="sd">            g = fmin(wMax, fmax(wMin, newWeight));</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>

    <span class="n">pre_spike_code</span><span class="o">=</span><span class="s2">&quot;preTrace += 1.0;&quot;</span><span class="p">,</span>
    <span class="n">pre_dynamics_code</span><span class="o">=</span><span class="s2">&quot;preTrace *= tauPlusDecay;&quot;</span><span class="p">,</span>
    <span class="n">post_spike_code</span><span class="o">=</span><span class="s2">&quot;postTrace += 1.0;&quot;</span><span class="p">,</span>
    <span class="n">post_dynamics_code</span><span class="o">=</span><span class="s2">&quot;postTrace *= tauMinusDecay;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<section id="synapse-dynamics">
<h3>Synapse dynamics<a class="headerlink" href="#synapse-dynamics" title="Permalink to this heading"></a></h3>
<p>Unlike the event-driven updates previously described, synapse dynamics code is run for each synapse and each timestep, i.e. it is time-driven.
This can be used where synapses have internal variables and dynamics that are described in continuous time, e.g. by ODEs.
However, using this mechanism is typically computationally very costly because of the large number of synapses in a typical network.
By using the <code class="docutils literal notranslate"><span class="pre">addToPost()</span></code> and <code class="docutils literal notranslate"><span class="pre">addToPostDelay()</span></code> functions discussed in the context of <code class="docutils literal notranslate"><span class="pre">pre_spike_syn_code</span></code>, the synapse dynamics can also be used to implement continuous synapses for rate-based models.
For example a continous synapse which multiplies a presynaptic neuron variable by the weight could be added to a weight update model definition as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pre_neuron_var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;V_pre&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>
<span class="n">synapse_dynamics_code</span><span class="o">=</span><span class="s2">&quot;addToPost(g * V_pre);&quot;</span><span class="p">,</span>
</pre></div>
</div>
</section>
<section id="spike-like-events">
<h3>Spike-like events<a class="headerlink" href="#spike-like-events" title="Permalink to this heading"></a></h3>
<p>As well as time-driven synapse dynamics and spike event-driven updates, GeNN weight update models also support “spike-like events”.
These can be triggered by a threshold condition evaluated on the pre or postsynaptic neuron.
This typically involves pre or postsynaptic weight update model variables or variable references respectively.</p>
<p>For example, to trigger a presynaptic spike-like event when the presynaptic neuron’s voltage is greater than 0.02, the following could be added to a weight update model definition:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pre_neuron_var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;V_pre&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>
<span class="n">pre_event_threshold_condition_code</span><span class="o">=</span><span class="s2">&quot;V_pre &gt; -0.02&quot;</span>
</pre></div>
</div>
<p>Whenever this expression evaluates to true, the event code in <code class="docutils literal notranslate"><span class="pre">pre_event_code</span></code> will be executed.</p>
</section>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_wu_egp_ref">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_wu_egp_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg0:</span> <span class="pre">GeNN::SynapseGroup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1:</span> <span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">GeNN::Models::EGPReference</span></span></span><a class="headerlink" href="#pygenn.create_wu_egp_ref" title="Permalink to this definition"></a></dt>
<dd><p>Creates a reference to a weight update model extra global parameter.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_wu_post_var_ref">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_wu_post_var_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg0:</span> <span class="pre">GeNN::SynapseGroup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1:</span> <span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">GeNN::Models::VarReference</span></span></span><a class="headerlink" href="#pygenn.create_wu_post_var_ref" title="Permalink to this definition"></a></dt>
<dd><p>Creates a reference to a weight update model postsynapticvariable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_wu_pre_var_ref">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_wu_pre_var_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg0:</span> <span class="pre">GeNN::SynapseGroup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1:</span> <span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">GeNN::Models::VarReference</span></span></span><a class="headerlink" href="#pygenn.create_wu_pre_var_ref" title="Permalink to this definition"></a></dt>
<dd><p>Creates a reference to a weight update model presynaptic variable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.create_wu_var_ref">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_wu_var_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.create_wu_var_ref" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>create_wu_var_ref(sg: GeNN::SynapseGroup, var_name: str, transpose_sg: GeNN::SynapseGroup = None, transpose_var_name: str = ‘’) -&gt; GeNN::Models::WUVarReference</p></li>
</ol>
<p>Creates a reference to a weight update model variable.</p>
<ol class="arabic simple" start="2">
<li><p>create_wu_var_ref(arg0: GeNN::CustomUpdateWU, arg1: str) -&gt; GeNN::Models::WUVarReference</p></li>
</ol>
<p>Creates a reference to a custom weight update variable.</p>
<ol class="arabic simple" start="3">
<li><p>create_wu_var_ref(arg0: GeNN::CustomConnectivityUpdate, arg1: str) -&gt; GeNN::Models::WUVarReference</p></li>
</ol>
<p>Creates a reference to a custom connectivity update update variable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.get_var_access_dim">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">get_var_access_dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.get_var_access_dim" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_var_access_dim(arg0: pygenn._genn.VarAccess) -&gt; pygenn._genn.VarAccessDim</p></li>
</ol>
<p>Extract variable dimensions from its access enumeration</p>
<ol class="arabic simple" start="2">
<li><p>get_var_access_dim(arg0: pygenn._genn.CustomUpdateVarAccess, arg1: pygenn._genn.VarAccessDim) -&gt; pygenn._genn.VarAccessDim</p></li>
</ol>
<p>Extract custom update variable dimensions from its access enumeration and dimensions of the custom update itself</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_postsynaptic">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">init_postsynaptic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">snippet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.init_postsynaptic" title="Permalink to this definition"></a></dt>
<dd><p>Initialises a postsynaptic model with parameter values,
variable initialisers and variable references</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>snippet</strong> (<em>PostsynapticModelBase</em><em> | </em><em>str</em>) – postsynaptic model either as a string referencing a built-in model
(see <a class="reference internal" href="#module-pygenn.postsynaptic_models" title="pygenn.postsynaptic_models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">postsynaptic_models</span></code></a>) or an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">PostsynapticModelBase</span></code> (for example returned
by <a class="reference internal" href="#pygenn.create_postsynaptic_model" title="pygenn.create_postsynaptic_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_postsynaptic_model()</span></code></a>)</p></li>
<li><p><strong>params</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>int</em><em> | </em><em>float</em><em>]</em>) – parameter values for the postsynaptic model (see <a class="reference internal" href="../building_networks.html#section-parameters"><span class="std std-ref">Parameters</span></a>)</p></li>
<li><p><strong>vars</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarInit</em><em> | </em><em>int</em><em> | </em><em>float</em><em> | </em><em>ndarray</em><em> | </em><em>Sequence</em><em>]</em>) – initial synaptic variable values or initialisers
for the postsynaptic model (see <a class="reference internal" href="../building_networks.html#section-variables"><span class="std std-ref">Variables</span></a>)</p></li>
<li><p><strong>var_refs</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarInit</em><em> | </em><em>int</em><em> | </em><em>float</em><em> | </em><em>ndarray</em><em> | </em><em>Sequence</em><em>]</em>) – references to postsynaptic neuron variables,
typically created using <a class="reference internal" href="#pygenn.create_var_ref" title="pygenn.create_var_ref"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_var_ref()</span></code></a>
(see <a class="reference internal" href="../building_networks.html#section-variables-references"><span class="std std-ref">Variables references</span></a>)</p></li>
</ul>
</dd>
</dl>
<p>For example, the built-in conductance model with exponential
current shaping could be initialised as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">postsynaptic_init</span> <span class="o">=</span> <span class="n">init_postsynaptic</span><span class="p">(</span><span class="s2">&quot;ExpCond&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;tau&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">80.0</span><span class="p">},</span>
                                      <span class="n">var_refs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;V&quot;</span><span class="p">:</span> <span class="n">create_var_ref</span><span class="p">(</span><span class="n">pop1</span><span class="p">,</span> <span class="s2">&quot;V&quot;</span><span class="p">)})</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">pop1</span></code> is a reference to the postsynaptic neuron population
(as returned by <a class="reference internal" href="#pygenn.GeNNModel.add_neuron_population" title="pygenn.GeNNModel.add_neuron_population"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.add_neuron_population()</span></code></a>)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_sparse_connectivity">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">init_sparse_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">snippet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.init_sparse_connectivity" title="Permalink to this definition"></a></dt>
<dd><p>Initialises a sparse connectivity initialisation snippet with parameter values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>snippet</strong> (<em>InitSparseConnectivitySnippetBase</em><em> | </em><em>str</em>) – sparse connectivity init snippet, either as a string referencing
a built-in snippet (see <a class="reference internal" href="#module-pygenn.init_sparse_connectivity_snippets" title="pygenn.init_sparse_connectivity_snippets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">init_sparse_connectivity_snippets</span></code></a>)
or an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">InitSparseConnectivitySnippetBase</span></code>
(for example returned by <a class="reference internal" href="#pygenn.create_sparse_connect_init_snippet" title="pygenn.create_sparse_connect_init_snippet"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_sparse_connect_init_snippet()</span></code></a>)</p></li>
<li><p><strong>params</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>int</em><em> | </em><em>float</em><em>]</em>) – parameter values for the sparse connectivity init snippet (see <a class="reference internal" href="../building_networks.html#section-parameters"><span class="std std-ref">Parameters</span></a>)</p></li>
</ul>
</dd>
</dl>
<p>For example, the built-in “FixedProbability” snippet could be used to generate connectivity
where each pair of pre and postsynaptic neurons is connected with a probability of 0.1:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">init</span> <span class="o">=</span> <span class="n">init_sparse_connectivity</span><span class="p">(</span><span class="s2">&quot;FixedProbability&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;prob&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_toeplitz_connectivity">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">init_toeplitz_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_toeplitz_connect_snippet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.init_toeplitz_connectivity" title="Permalink to this definition"></a></dt>
<dd><p>Initialises a toeplitz connectivity
initialisation snippet with parameter values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>snippet</strong> – toeplitz connectivity init snippet, either as a string referencing
a built-in snippet (see <a class="reference internal" href="#module-pygenn.init_toeplitz_connectivity_snippets" title="pygenn.init_toeplitz_connectivity_snippets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">init_toeplitz_connectivity_snippets</span></code></a>)
or an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">InitToeplitzConnectivitySnippetBase</span></code>
(for example returned by <a class="reference internal" href="#pygenn.create_toeplitz_connect_init_snippet" title="pygenn.create_toeplitz_connect_init_snippet"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_toeplitz_connect_init_snippet()</span></code></a>)</p></li>
<li><p><strong>params</strong> – parameter values for the toeplitz connectivity init snippet (see <a class="reference internal" href="../building_networks.html#section-parameters"><span class="std std-ref">Parameters</span></a>)</p></li>
</ul>
</dd>
</dl>
<p>For example, the built-in “Conv2D” snippet could be used to generate 2D convolutional
connectivity with a <span class="math notranslate nohighlight">\(3 \times 3\)</span> kernel, a <span class="math notranslate nohighlight">\(64 \times 64 \times 1\)</span> input
and a <span class="math notranslate nohighlight">\(62 \times 62 \times 1\)</span> output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;conv_kh&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;conv_kw&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
          <span class="s2">&quot;conv_ih&quot;</span><span class="p">:</span> <span class="mi">64</span><span class="p">,</span> <span class="s2">&quot;conv_iw&quot;</span><span class="p">:</span> <span class="mi">64</span><span class="p">,</span> <span class="s2">&quot;conv_ic&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
          <span class="s2">&quot;conv_oh&quot;</span><span class="p">:</span> <span class="mi">62</span><span class="p">,</span> <span class="s2">&quot;conv_ow&quot;</span><span class="p">:</span> <span class="mi">62</span><span class="p">,</span> <span class="s2">&quot;conv_oc&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

<span class="n">init</span> <span class="o">=</span> <span class="n">init_toeplitz_connectivity</span><span class="p">(</span><span class="s2">&quot;Conv2D&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This should be used to connect a presynaptic neuron population with
<span class="math notranslate nohighlight">\(64 \times 64 \times 1 = 4096\)</span> neurons to a postsynaptic neuron
population with <span class="math notranslate nohighlight">\(62 \times 62 \times 1 = 3844\)</span> neurons.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_var">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">init_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">snippet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.init_var" title="Permalink to this definition"></a></dt>
<dd><p>Initialises a variable initialisation snippet with parameter values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>snippet</strong> (<em>InitVarSnippetBase</em><em> | </em><em>str</em>) – variable init snippet, either as a string referencing
a built-in snippet (see <a class="reference internal" href="#module-pygenn.init_var_snippets" title="pygenn.init_var_snippets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">init_var_snippets</span></code></a>)
or an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">InitVarSnippetBase</span></code>
(for example returned by <a class="reference internal" href="#pygenn.create_var_init_snippet" title="pygenn.create_var_init_snippet"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_var_init_snippet()</span></code></a>)</p></li>
<li><p><strong>params</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>int</em><em> | </em><em>float</em><em>]</em>) – parameter values for the variable init snippet (see <a class="reference internal" href="../building_networks.html#section-parameters"><span class="std std-ref">Parameters</span></a>)</p></li>
</ul>
</dd>
</dl>
<p>For example, the built-in model “Normal” could be used to initialise a variable
by sampling from the normal distribution with a mean of 0 and a standard deviation of 1:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">init</span> <span class="o">=</span> <span class="n">init_var</span><span class="p">(</span><span class="s2">&quot;Normal&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;sd&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_weight_update">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">init_weight_update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">snippet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.init_weight_update" title="Permalink to this definition"></a></dt>
<dd><p>Initialises a weight update model with parameter values,
variable initialisers and variable references.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>snippet</strong> – weight update model either as a string referencing a built-in model
(see <a class="reference internal" href="#module-pygenn.weight_update_models" title="pygenn.weight_update_models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">weight_update_models</span></code></a>) or an instance of
<code class="xref py py-class docutils literal notranslate"><span class="pre">WeightUpdateModelBase</span></code> (for example returned
by <a class="reference internal" href="#pygenn.create_weight_update_model" title="pygenn.create_weight_update_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_weight_update_model()</span></code></a>)</p></li>
<li><p><strong>params</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>int</em><em> | </em><em>float</em><em>]</em>) – parameter values (see <a class="reference internal" href="../building_networks.html#section-parameters"><span class="std std-ref">Parameters</span></a>)</p></li>
<li><p><strong>vars</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarInit</em><em> | </em><em>int</em><em> | </em><em>float</em><em> | </em><em>ndarray</em><em> | </em><em>Sequence</em><em>]</em>) – initial synaptic variable values or
initialisers (see <a class="reference internal" href="../building_networks.html#section-variables"><span class="std std-ref">Variables</span></a>)</p></li>
<li><p><strong>pre_vars</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarInit</em><em> | </em><em>int</em><em> | </em><em>float</em><em> | </em><em>ndarray</em><em> | </em><em>Sequence</em><em>]</em>) – initial presynaptic variable values or
initialisers (see <a class="reference internal" href="../building_networks.html#section-variables"><span class="std std-ref">Variables</span></a>)</p></li>
<li><p><strong>post_vars</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarInit</em><em> | </em><em>int</em><em> | </em><em>float</em><em> | </em><em>ndarray</em><em> | </em><em>Sequence</em><em>]</em>) – initial postsynaptic variable values or initialisers
(see <a class="reference internal" href="../building_networks.html#section-variables"><span class="std std-ref">Variables</span></a>)</p></li>
<li><p><strong>pre_var_refs</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarReference</em><em>]</em>) – references to presynaptic neuron variables,
typically created using <a class="reference internal" href="#pygenn.create_var_ref" title="pygenn.create_var_ref"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_var_ref()</span></code></a>
(see <a class="reference internal" href="../building_networks.html#section-variables-references"><span class="std std-ref">Variables references</span></a>)</p></li>
<li><p><strong>post_var_refs</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>VarReference</em><em>]</em>) – references to postsynaptic neuron variables,
typically created using <a class="reference internal" href="#pygenn.create_var_ref" title="pygenn.create_var_ref"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_var_ref()</span></code></a>
(see <a class="reference internal" href="../building_networks.html#section-variables-references"><span class="std std-ref">Variables references</span></a>)</p></li>
</ul>
</dd>
</dl>
<p>For example, the built-in static pulse model with
constant weights could be initialised as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">weight_init</span> <span class="o">=</span> <span class="n">init_weight_update</span><span class="p">(</span><span class="s2">&quot;StaticPulseConstantWeight&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>

<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-pygenn.cuda_backend">
<span id="pygenn-cuda-backend-module"></span><h2>pygenn.cuda_backend module<a class="headerlink" href="#module-pygenn.cuda_backend" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pygenn.cuda_backend.BlockSizeSelect">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.cuda_backend.</span></span><span class="sig-name descname"><span class="pre">BlockSizeSelect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.cuda_backend.BlockSizeSelect" title="pygenn.cuda_backend.BlockSizeSelect"><span class="pre">pygenn.cuda_backend.BlockSizeSelect</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.cuda_backend.BlockSizeSelect" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Methods for selecting CUDA kernel block size</p>
<p>Members:</p>
<blockquote>
<div><p>OCCUPANCY : Pick optimal blocksize for each kernel based on occupancy</p>
<p>MANUAL : Use block sizes specified by user</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.cuda_backend.BlockSizeSelect.MANUAL">
<span class="sig-name descname"><span class="pre">MANUAL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;BlockSizeSelect.MANUAL:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pygenn.cuda_backend.BlockSizeSelect.MANUAL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.cuda_backend.BlockSizeSelect.OCCUPANCY">
<span class="sig-name descname"><span class="pre">OCCUPANCY</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;BlockSizeSelect.OCCUPANCY:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pygenn.cuda_backend.BlockSizeSelect.OCCUPANCY" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.BlockSizeSelect.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.cuda_backend.BlockSizeSelect.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.BlockSizeSelect.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.cuda_backend.BlockSizeSelect.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.cuda_backend.DeviceSelect">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.cuda_backend.</span></span><span class="sig-name descname"><span class="pre">DeviceSelect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.cuda_backend.DeviceSelect" title="pygenn.cuda_backend.DeviceSelect"><span class="pre">pygenn.cuda_backend.DeviceSelect</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.cuda_backend.DeviceSelect" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Methods for selecting CUDA device</p>
<p>Members:</p>
<blockquote>
<div><p>OPTIMAL : Pick optimal device based on how well kernels can be simultaneously simulated and occupancy</p>
<p>MOST_MEMORY : Pick device with most global memory</p>
<p>MANUAL : Use device specified by user</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.cuda_backend.DeviceSelect.MANUAL">
<span class="sig-name descname"><span class="pre">MANUAL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DeviceSelect.MANUAL:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pygenn.cuda_backend.DeviceSelect.MANUAL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.cuda_backend.DeviceSelect.MOST_MEMORY">
<span class="sig-name descname"><span class="pre">MOST_MEMORY</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DeviceSelect.MOST_MEMORY:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pygenn.cuda_backend.DeviceSelect.MOST_MEMORY" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pygenn.cuda_backend.DeviceSelect.OPTIMAL">
<span class="sig-name descname"><span class="pre">OPTIMAL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;DeviceSelect.OPTIMAL:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pygenn.cuda_backend.DeviceSelect.OPTIMAL" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.DeviceSelect.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pygenn.cuda_backend.DeviceSelect.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.DeviceSelect.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pygenn.cuda_backend.DeviceSelect.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.cuda_backend.Preferences">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.cuda_backend.</span></span><span class="sig-name descname"><span class="pre">Preferences</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.cuda_backend.Preferences" title="pygenn.cuda_backend.Preferences"><span class="pre">pygenn.cuda_backend.Preferences</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.cuda_backend.Preferences" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">PreferencesBase</span></code></p>
<p>Preferences for CUDA backend</p>
<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.Preferences.block_size_select_method">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">block_size_select_method</span></span><a class="headerlink" href="#pygenn.cuda_backend.Preferences.block_size_select_method" title="Permalink to this definition"></a></dt>
<dd><p>How to select CUDA blocksize</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.Preferences.constant_cache_overhead">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">constant_cache_overhead</span></span><a class="headerlink" href="#pygenn.cuda_backend.Preferences.constant_cache_overhead" title="Permalink to this definition"></a></dt>
<dd><p>How much constant cache is already used and therefore can’t be used by GeNN?
Each of the four modules which includes CUDA headers(neuronUpdate, synapseUpdate, custom update, init and runner)
Takes 72 bytes of constant memory for a lookup table used by cuRAND. If your application requires
additional constant cache, increase this</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.Preferences.device_select_method">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device_select_method</span></span><a class="headerlink" href="#pygenn.cuda_backend.Preferences.device_select_method" title="Permalink to this definition"></a></dt>
<dd><p>How to select GPU device</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.Preferences.enable_nccl_reductions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enable_nccl_reductions</span></span><a class="headerlink" href="#pygenn.cuda_backend.Preferences.enable_nccl_reductions" title="Permalink to this definition"></a></dt>
<dd><p>Generate corresponding NCCL batch reductions</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.Preferences.generate_line_info">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate_line_info</span></span><a class="headerlink" href="#pygenn.cuda_backend.Preferences.generate_line_info" title="Permalink to this definition"></a></dt>
<dd><p>Should line info be included in resultant executable for debugging/profiling purposes?</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.Preferences.manual_block_sizes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">manual_block_sizes</span></span><a class="headerlink" href="#pygenn.cuda_backend.Preferences.manual_block_sizes" title="Permalink to this definition"></a></dt>
<dd><p>If block size select method is set to BlockSizeSelect::MANUAL, block size to use for each kernel</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.Preferences.manual_device_id">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">manual_device_id</span></span><a class="headerlink" href="#pygenn.cuda_backend.Preferences.manual_device_id" title="Permalink to this definition"></a></dt>
<dd><p>If device select method is set to DeviceSelect::MANUAL, id of device to use</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.cuda_backend.Preferences.show_ptx_info">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">show_ptx_info</span></span><a class="headerlink" href="#pygenn.cuda_backend.Preferences.show_ptx_info" title="Permalink to this definition"></a></dt>
<dd><p>Should PTX assembler information be displayed for each CUDA kernel during compilation?</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-pygenn.current_source_models">
<span id="pygenn-current-source-models-module"></span><h2>pygenn.current_source_models module<a class="headerlink" href="#module-pygenn.current_source_models" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pygenn.current_source_models.DC">
<span class="sig-prename descclassname"><span class="pre">pygenn.current_source_models.</span></span><span class="sig-name descname"><span class="pre">DC</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.CurrentSourceModelBase</span></span></span><a class="headerlink" href="#pygenn.current_source_models.DC" title="Permalink to this definition"></a></dt>
<dd><p>DC source
It has a single parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">amp</span></code>    - amplitude of the current [nA]</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.current_source_models.GaussianNoise">
<span class="sig-prename descclassname"><span class="pre">pygenn.current_source_models.</span></span><span class="sig-name descname"><span class="pre">GaussianNoise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.CurrentSourceModelBase</span></span></span><a class="headerlink" href="#pygenn.current_source_models.GaussianNoise" title="Permalink to this definition"></a></dt>
<dd><p>Noisy current source with noise drawn from normal distribution
It has 2 parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mean</span></code>   - mean of the normal distribution [nA]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sd</span></code>     - standard deviation of the normal distribution [nA]</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.current_source_models.PoissonExp">
<span class="sig-prename descclassname"><span class="pre">pygenn.current_source_models.</span></span><span class="sig-name descname"><span class="pre">PoissonExp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.CurrentSourceModelBase</span></span></span><a class="headerlink" href="#pygenn.current_source_models.PoissonExp" title="Permalink to this definition"></a></dt>
<dd><p>Current source for injecting a current equivalent to a population of
Poisson spike sources, one-to-one connected with exponential synapses
It has 3 parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">weight</span></code> - synaptic weight of the Poisson spikes [nA]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tauSyn</span></code> - decay time constant [ms]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rate</span></code>   - mean firing rate [Hz]</p></li>
</ul>
</dd></dl>

</section>
<section id="module-pygenn.custom_connectivity_update_models">
<span id="pygenn-custom-connectivity-update-models-module"></span><h2>pygenn.custom_connectivity_update_models module<a class="headerlink" href="#module-pygenn.custom_connectivity_update_models" title="Permalink to this heading"></a></h2>
</section>
<section id="module-pygenn.custom_update_models">
<span id="pygenn-custom-update-models-module"></span><h2>pygenn.custom_update_models module<a class="headerlink" href="#module-pygenn.custom_update_models" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pygenn.custom_update_models.Transpose">
<span class="sig-prename descclassname"><span class="pre">pygenn.custom_update_models.</span></span><span class="sig-name descname"><span class="pre">Transpose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.CustomUpdateModelBase</span></span></span><a class="headerlink" href="#pygenn.custom_update_models.Transpose" title="Permalink to this definition"></a></dt>
<dd><p>Minimal custom update model for calculating tranpose</p>
</dd></dl>

</section>
<section id="module-pygenn.genn_groups">
<span id="pygenn-genn-groups-module"></span><h2>pygenn.genn_groups module<a class="headerlink" href="#module-pygenn.genn_groups" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pygenn.genn_groups.CurrentSourceMixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.genn_groups.</span></span><span class="sig-name descname"><span class="pre">CurrentSourceMixin</span></span><a class="headerlink" href="#pygenn.genn_groups.CurrentSourceMixin" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.genn_groups.GroupMixin" title="pygenn.genn_groups.GroupMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupMixin</span></code></a></p>
<p>Mixin added to current source objects</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.genn_groups.CustomConnectivityUpdateMixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.genn_groups.</span></span><span class="sig-name descname"><span class="pre">CustomConnectivityUpdateMixin</span></span><a class="headerlink" href="#pygenn.genn_groups.CustomConnectivityUpdateMixin" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.genn_groups.GroupMixin" title="pygenn.genn_groups.GroupMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupMixin</span></code></a></p>
<p>Mixin added to custom connectivity update objects</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pre_vars</strong> – Dictionary mapping custom connectivity update model variable
names to <a class="reference internal" href="#pygenn.model_preprocessor.Variable" title="pygenn.model_preprocessor.Variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygenn.model_preprocessor.Variable</span></code></a> objects</p></li>
<li><p><strong>post_vars</strong> – Dictionary mapping custom connectivity update model variable
names to <a class="reference internal" href="#pygenn.model_preprocessor.Variable" title="pygenn.model_preprocessor.Variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygenn.model_preprocessor.Variable</span></code></a> objects</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.genn_groups.CustomUpdateMixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.genn_groups.</span></span><span class="sig-name descname"><span class="pre">CustomUpdateMixin</span></span><a class="headerlink" href="#pygenn.genn_groups.CustomUpdateMixin" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.genn_groups.GroupMixin" title="pygenn.genn_groups.GroupMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupMixin</span></code></a></p>
<p>Mixin added to custom update objects</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.genn_groups.CustomUpdateWUMixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.genn_groups.</span></span><span class="sig-name descname"><span class="pre">CustomUpdateWUMixin</span></span><a class="headerlink" href="#pygenn.genn_groups.CustomUpdateWUMixin" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.genn_groups.GroupMixin" title="pygenn.genn_groups.GroupMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupMixin</span></code></a></p>
<p>Mixin added to custom update WU objects</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.genn_groups.GroupMixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.genn_groups.</span></span><span class="sig-name descname"><span class="pre">GroupMixin</span></span><a class="headerlink" href="#pygenn.genn_groups.GroupMixin" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This is the base class for the mixins added to all types of groups.
It provides basic functionality for handling variables,
extra global parameters and dynamic parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vars</strong> – Dictionary mapping variable names to objects derived from
<a class="reference internal" href="#pygenn.model_preprocessor.VariableBase" title="pygenn.model_preprocessor.VariableBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygenn.model_preprocessor.VariableBase</span></code></a></p></li>
<li><p><strong>extra_global_params</strong> – Dictionary mapping extra global parameters names
to <a class="reference internal" href="#pygenn.model_preprocessor.ExtraGlobalParameter" title="pygenn.model_preprocessor.ExtraGlobalParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygenn.model_preprocessor.ExtraGlobalParameter</span></code></a>
objects</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pygenn.genn_groups.GroupMixin.set_dynamic_param_value">
<span class="sig-name descname"><span class="pre">set_dynamic_param_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.genn_groups.GroupMixin.set_dynamic_param_value" title="Permalink to this definition"></a></dt>
<dd><p>Set the value of a dynamic parameter at runtime</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – name of the parameter</p></li>
<li><p><strong>value</strong> (<em>float</em><em> | </em><em>int</em>) – numeric value to assign to parameters</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.genn_groups.NeuronGroupMixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.genn_groups.</span></span><span class="sig-name descname"><span class="pre">NeuronGroupMixin</span></span><a class="headerlink" href="#pygenn.genn_groups.NeuronGroupMixin" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.genn_groups.GroupMixin" title="pygenn.genn_groups.GroupMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupMixin</span></code></a></p>
<p>Mixin added to neuron group objects
It provides additional functionality for recording spikes</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spike_times</strong> – <a class="reference internal" href="#pygenn.model_preprocessor.Array" title="pygenn.model_preprocessor.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygenn.model_preprocessor.Array</span></code></a> that,
if spike tikes are required, will provide
interface for pushing, pulling and accessing them</p></li>
<li><p><strong>prev_spike_times</strong> – <a class="reference internal" href="#pygenn.model_preprocessor.Array" title="pygenn.model_preprocessor.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygenn.model_preprocessor.Array</span></code></a> that,
if previous spike tikes are required, will provide
interface for pushing, pulling and accessing them</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pygenn.genn_groups.NeuronGroupMixin.spike_recording_data">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">spike_recording_data</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pygenn.genn_groups.NeuronGroupMixin.spike_recording_data" title="Permalink to this definition"></a></dt>
<dd><p>Spike recording data associated with this neuron group.</p>
<p>Before accessing this property,
<a class="reference internal" href="#pygenn.GeNNModel.pull_recording_buffers_from_device" title="pygenn.GeNNModel.pull_recording_buffers_from_device"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.pull_recording_buffers_from_device()</span></code></a>
must be called to copy spike recording data from device</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.genn_groups.SynapseGroupMixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.genn_groups.</span></span><span class="sig-name descname"><span class="pre">SynapseGroupMixin</span></span><a class="headerlink" href="#pygenn.genn_groups.SynapseGroupMixin" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.genn_groups.GroupMixin" title="pygenn.genn_groups.GroupMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupMixin</span></code></a></p>
<p>Mixin added to synapse group objects
It provides additional functionality for recording spike events
and handling connectivity</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pre_vars</strong> – Dictionary mapping presynapatic weight
update model variable names to
<a class="reference internal" href="#pygenn.model_preprocessor.Variable" title="pygenn.model_preprocessor.Variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygenn.model_preprocessor.Variable</span></code></a> objects</p></li>
<li><p><strong>post_vars</strong> – Dictionary mapping postsynapatic weight
update model variable names to
<a class="reference internal" href="#pygenn.model_preprocessor.Variable" title="pygenn.model_preprocessor.Variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygenn.model_preprocessor.Variable</span></code></a> objects</p></li>
<li><p><strong>psm_vars</strong> – Dictionary mapping postsynaptic model variable names to
<a class="reference internal" href="#pygenn.model_preprocessor.Variable" title="pygenn.model_preprocessor.Variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygenn.model_preprocessor.Variable</span></code></a> objects</p></li>
<li><p><strong>psm_extra_global_params</strong> – Dictionary mapping postsynaptic model
extra global parameters names to
<a class="reference internal" href="#pygenn.model_preprocessor.ExtraGlobalParameter" title="pygenn.model_preprocessor.ExtraGlobalParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygenn.model_preprocessor.ExtraGlobalParameter</span></code></a>
objects</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pygenn.genn_groups.SynapseGroupMixin.get_sparse_post_inds">
<span class="sig-name descname"><span class="pre">get_sparse_post_inds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.genn_groups.SynapseGroupMixin.get_sparse_post_inds" title="Permalink to this definition"></a></dt>
<dd><p>Get postsynaptic indices of synapse group connections</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>postsynaptic indices</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.genn_groups.SynapseGroupMixin.get_sparse_pre_inds">
<span class="sig-name descname"><span class="pre">get_sparse_pre_inds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.genn_groups.SynapseGroupMixin.get_sparse_pre_inds" title="Permalink to this definition"></a></dt>
<dd><p>Get presynaptic indices of synapse group connections</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>presynaptic indices</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.genn_groups.SynapseGroupMixin.post_spike_event_recording_data">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">post_spike_event_recording_data</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pygenn.genn_groups.SynapseGroupMixin.post_spike_event_recording_data" title="Permalink to this definition"></a></dt>
<dd><p>Postsynaptic spike-event recording data associated with this
synapse group.</p>
<p>Before accessing this property,
<a class="reference internal" href="#pygenn.GeNNModel.pull_recording_buffers_from_device" title="pygenn.GeNNModel.pull_recording_buffers_from_device"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.pull_recording_buffers_from_device()</span></code></a>
must be called to copy spike recording data from device</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.genn_groups.SynapseGroupMixin.pre_spike_event_recording_data">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pre_spike_event_recording_data</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#pygenn.genn_groups.SynapseGroupMixin.pre_spike_event_recording_data" title="Permalink to this definition"></a></dt>
<dd><p>Presynaptic spike-event recording data associated with this
synapse group.</p>
<p>Before accessing this property,
<a class="reference internal" href="#pygenn.GeNNModel.pull_recording_buffers_from_device" title="pygenn.GeNNModel.pull_recording_buffers_from_device"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.pull_recording_buffers_from_device()</span></code></a>
must be called to copy spike recording data from device</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.genn_groups.SynapseGroupMixin.pull_connectivity_from_device">
<span class="sig-name descname"><span class="pre">pull_connectivity_from_device</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.genn_groups.SynapseGroupMixin.pull_connectivity_from_device" title="Permalink to this definition"></a></dt>
<dd><p>Pull connectivity from device</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.genn_groups.SynapseGroupMixin.push_connectivity_to_device">
<span class="sig-name descname"><span class="pre">push_connectivity_to_device</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.genn_groups.SynapseGroupMixin.push_connectivity_to_device" title="Permalink to this definition"></a></dt>
<dd><p>Push connectivity to device</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.genn_groups.SynapseGroupMixin.set_sparse_connections">
<span class="sig-name descname"><span class="pre">set_sparse_connections</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pre_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_indices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.genn_groups.SynapseGroupMixin.set_sparse_connections" title="Permalink to this definition"></a></dt>
<dd><p>Manually provide indices of sparse synapses between two groups of neurons</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pre_indices</strong> (<em>Sequence</em><em>[</em><em>int</em><em>] </em><em>| </em><em>ndarray</em>) – presynaptic indices</p></li>
<li><p><strong>post_indices</strong> (<em>Sequence</em><em>[</em><em>int</em><em>] </em><em>| </em><em>ndarray</em>) – postsynaptic indices</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.genn_groups.SynapseGroupMixin.synapse_group">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">synapse_group</span></span><a class="headerlink" href="#pygenn.genn_groups.SynapseGroupMixin.synapse_group" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.genn_groups.SynapseGroupMixin.weight_update_var_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">weight_update_var_size</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#pygenn.genn_groups.SynapseGroupMixin.weight_update_var_size" title="Permalink to this definition"></a></dt>
<dd><p>Size of each weight update variable</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-pygenn.init_sparse_connectivity_snippets">
<span id="pygenn-init-sparse-connectivity-snippets-module"></span><h2>pygenn.init_sparse_connectivity_snippets module<a class="headerlink" href="#module-pygenn.init_sparse_connectivity_snippets" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_sparse_connectivity_snippets.Conv2D">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_sparse_connectivity_snippets.</span></span><span class="sig-name descname"><span class="pre">Conv2D</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitSparseConnectivitySnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_sparse_connectivity_snippets.Conv2D" title="Permalink to this definition"></a></dt>
<dd><p>Initialises 2D convolutional connectivity
Row build state variables are used to convert presynaptic neuron index to rows, columns and channels and,
from these, to calculate the range of postsynaptic rows, columns and channels connections will be made within.
This sparse connectivity snippet does not support multiple threads per neuron
This snippet takes 12 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">conv_kh</span></code> - height of 2D convolution kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_kw</span></code> - width of 2D convolution kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_sh</span></code> - height of convolution stride</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_sw</span></code> - width of convolution stride</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_padh</span></code> - width of padding around input</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_padw</span></code> - height of padding around input</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_ih</span></code> - width of input to this convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_iw</span></code> - height of input to this convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_ic</span></code> - number of input channels to this convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_oh</span></code> - width of output from this convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_ow</span></code> - height of output from this convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_oc</span></code> - number of output channels from this convolution</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">conv_ih</span> <span class="pre">*</span> <span class="pre">conv_iw</span> <span class="pre">*</span> <span class="pre">conv_ic</span></code> should equal the number of neurons in the presynaptic
neuron population and <code class="docutils literal notranslate"><span class="pre">conv_oh</span> <span class="pre">*</span> <span class="pre">conv_ow</span> <span class="pre">*</span> <span class="pre">conv_oc</span></code> should equal the number of
neurons in the postsynaptic neuron population.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_sparse_connectivity_snippets.FixedNumberPostWithReplacement">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_sparse_connectivity_snippets.</span></span><span class="sig-name descname"><span class="pre">FixedNumberPostWithReplacement</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitSparseConnectivitySnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_sparse_connectivity_snippets.FixedNumberPostWithReplacement" title="Permalink to this definition"></a></dt>
<dd><p>Initialises connectivity with a fixed number of random synapses per row.
The postsynaptic targets of the synapses can be initialised in parallel by sampling from the discrete
uniform distribution. However, to sample connections in ascending order, we sample from the 1st order statistic
of the uniform distribution – Beta[1, Npost] – essentially the next smallest value. In this special case
this is equivalent to the exponential distribution which can be sampled in constant time using the inversion method.
This snippet takes 1 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num</span></code> - number of postsynaptic neurons to connect each presynaptic neuron to.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_sparse_connectivity_snippets.FixedNumberPreWithReplacement">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_sparse_connectivity_snippets.</span></span><span class="sig-name descname"><span class="pre">FixedNumberPreWithReplacement</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitSparseConnectivitySnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_sparse_connectivity_snippets.FixedNumberPreWithReplacement" title="Permalink to this definition"></a></dt>
<dd><p>Initialises connectivity with a fixed number of random synapses per column.
No need for ordering here so fine to sample directly from uniform distribution
This snippet takes 1 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num</span></code> - number of presynaptic neurons to connect each postsynaptic neuron to.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_sparse_connectivity_snippets.FixedNumberTotalWithReplacement">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_sparse_connectivity_snippets.</span></span><span class="sig-name descname"><span class="pre">FixedNumberTotalWithReplacement</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitSparseConnectivitySnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_sparse_connectivity_snippets.FixedNumberTotalWithReplacement" title="Permalink to this definition"></a></dt>
<dd><p>Initialises connectivity with a total number of random synapses.
The first stage in using this connectivity is to determine how many of the total synapses end up in each row.
This can be determined by sampling from the multinomial distribution. However, this operation cannot be
efficiently parallelised so must be performed on the host and the result passed as an extra global parameter array.
Once the length of each row is determined, the postsynaptic targets of the synapses can be initialised in parallel
by sampling from the discrete uniform distribution. However, to sample connections in ascending order, we sample
from the 1st order statistic of the uniform distribution – Beta[1, Npost] – essentially the next smallest value.
In this special case this is equivalent to the exponential distribution which can be sampled in constant time using the inversion method.
This snippet takes 1 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num</span></code> - total number of synapses to distribute throughout synaptic matrix.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_sparse_connectivity_snippets.FixedProbability">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_sparse_connectivity_snippets.</span></span><span class="sig-name descname"><span class="pre">FixedProbability</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitSparseConnectivitySnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_sparse_connectivity_snippets.FixedProbability" title="Permalink to this definition"></a></dt>
<dd><p>Initialises connectivity with a fixed probability of a synapse existing
between a pair of pre and postsynaptic neurons.
Whether a synapse exists between a pair of pre and a postsynaptic
neurons can be modelled using a Bernoulli distribution. While this COULD
be sampled directly by repeatedly drawing from the uniform distribution,
this is inefficient. Instead we sample from the geometric distribution
which describes “the probability distribution of the number of Bernoulli
trials needed to get one success” – essentially the distribution of the
‘gaps’ between synapses. We do this using the “inversion method”
described by Devroye (1986) – essentially inverting the CDF of the
equivalent continuous distribution (in this case the exponential distribution)
This snippet takes 1 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">prob</span></code> - probability of connection in [0, 1]</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_sparse_connectivity_snippets.FixedProbabilityNoAutapse">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_sparse_connectivity_snippets.</span></span><span class="sig-name descname"><span class="pre">FixedProbabilityNoAutapse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitSparseConnectivitySnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_sparse_connectivity_snippets.FixedProbabilityNoAutapse" title="Permalink to this definition"></a></dt>
<dd><p>Initialises connectivity with a fixed probability of a synapse existing
between a pair of pre and postsynaptic neurons. This version ensures there
are no autapses - connections between neurons with the same id
so should be used for recurrent connections.
Whether a synapse exists between a pair of pre and a postsynaptic
neurons can be modelled using a Bernoulli distribution. While this COULD
br sampling directly by repeatedly drawing from the uniform distribution,
this is innefficient. Instead we sample from the gemetric distribution
which describes “the probability distribution of the number of Bernoulli
trials needed to get one success” – essentially the distribution of the
‘gaps’ between synapses. We do this using the “inversion method”
described by Devroye (1986) – essentially inverting the CDF of the
equivalent continuous distribution (in this case the exponential distribution)
This snippet takes 1 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">prob</span></code> - probability of connection in [0, 1]</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_sparse_connectivity_snippets.OneToOne">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_sparse_connectivity_snippets.</span></span><span class="sig-name descname"><span class="pre">OneToOne</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitSparseConnectivitySnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_sparse_connectivity_snippets.OneToOne" title="Permalink to this definition"></a></dt>
<dd><p>Initialises connectivity to a ‘one-to-one’ diagonal matrix
This snippet has no parameters</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_sparse_connectivity_snippets.Uninitialised">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_sparse_connectivity_snippets.</span></span><span class="sig-name descname"><span class="pre">Uninitialised</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitSparseConnectivitySnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_sparse_connectivity_snippets.Uninitialised" title="Permalink to this definition"></a></dt>
<dd><p>Used to mark connectivity as uninitialised - no initialisation code will be run</p>
</dd></dl>

</section>
<section id="module-pygenn.init_toeplitz_connectivity_snippets">
<span id="pygenn-init-toeplitz-connectivity-snippets-module"></span><h2>pygenn.init_toeplitz_connectivity_snippets module<a class="headerlink" href="#module-pygenn.init_toeplitz_connectivity_snippets" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_toeplitz_connectivity_snippets.AvgPoolConv2D">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_toeplitz_connectivity_snippets.</span></span><span class="sig-name descname"><span class="pre">AvgPoolConv2D</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitToeplitzConnectivitySnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_toeplitz_connectivity_snippets.AvgPoolConv2D" title="Permalink to this definition"></a></dt>
<dd><p>Initialises 2D convolutional connectivity preceded by averaging pooling
Row build state variables are used to convert presynaptic neuron index to rows, columns and channels and,
from these, to calculate the range of postsynaptic rows, columns and channels connections will be made within.
This snippet takes 12 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">conv_kh</span></code> - height of 2D convolution kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_kw</span></code> - width of 2D convolution kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pool_kh</span></code> - height of 2D average pooling kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pool_kw</span></code> - width of 2D average pooling kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pool_sh</span></code> - height of average pooling stride</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pool_sw</span></code> - width of average pooling stride</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pool_ih</span></code> - width of input to the average pooling</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pool_iw</span></code> - height of input to the average pooling</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pool_ic</span></code> - number of input channels to the average pooling</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_oh</span></code> - width of output from the convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_ow</span></code> - height of output from the convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_oc</span></code> - number of output channels the this convolution</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_toeplitz_connectivity_snippets.Conv2D">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_toeplitz_connectivity_snippets.</span></span><span class="sig-name descname"><span class="pre">Conv2D</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitToeplitzConnectivitySnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_toeplitz_connectivity_snippets.Conv2D" title="Permalink to this definition"></a></dt>
<dd><p>Initialises 2D convolutional connectivity
Row build state variables are used to convert presynaptic neuron index to rows, columns and channels and,
from these, to calculate the range of postsynaptic rows, columns and channels connections will be made within.
This snippet takes 8 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">conv_kh</span></code> - height of 2D convolution kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_kw</span></code> - width of 2D convolution kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_ih</span></code> - width of input to this convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_iw</span></code> - height of input to this convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_ic</span></code> - number of input channels to this convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_oh</span></code> - width of output from this convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_ow</span></code> - height of output from this convolution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conv_oc</span></code> - number of output channels from this convolution</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_toeplitz_connectivity_snippets.Uninitialised">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_toeplitz_connectivity_snippets.</span></span><span class="sig-name descname"><span class="pre">Uninitialised</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitToeplitzConnectivitySnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_toeplitz_connectivity_snippets.Uninitialised" title="Permalink to this definition"></a></dt>
<dd><p>Used to mark connectivity as uninitialised - no initialisation code will be run</p>
</dd></dl>

</section>
<section id="module-pygenn.init_var_snippets">
<span id="pygenn-init-var-snippets-module"></span><h2>pygenn.init_var_snippets module<a class="headerlink" href="#module-pygenn.init_var_snippets" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_var_snippets.Binomial">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_var_snippets.</span></span><span class="sig-name descname"><span class="pre">Binomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitVarSnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_var_snippets.Binomial" title="Permalink to this definition"></a></dt>
<dd><p>Initialises variable by sampling from the binomial distribution
This snippet takes 2 parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> - number of trials</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code> - success probability for each trial</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_var_snippets.Constant">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_var_snippets.</span></span><span class="sig-name descname"><span class="pre">Constant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitVarSnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_var_snippets.Constant" title="Permalink to this definition"></a></dt>
<dd><p>Initialises variable to a constant value
This snippet takes 1 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code> - The value to intialise the variable to</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This snippet type is seldom used directly - InitVarSnippet::Init
has an implicit constructor that, internally, creates one of these snippets</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_var_snippets.Exponential">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_var_snippets.</span></span><span class="sig-name descname"><span class="pre">Exponential</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitVarSnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_var_snippets.Exponential" title="Permalink to this definition"></a></dt>
<dd><p>Initialises variable by sampling from the exponential distribution
This snippet takes 1 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lambda</span></code> - mean event rate (events per unit time/distance)</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_var_snippets.Gamma">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_var_snippets.</span></span><span class="sig-name descname"><span class="pre">Gamma</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitVarSnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_var_snippets.Gamma" title="Permalink to this definition"></a></dt>
<dd><p>Initialises variable by sampling from the gamma distribution
This snippet takes 2 parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> - distribution shape</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> - distribution scale</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_var_snippets.Kernel">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_var_snippets.</span></span><span class="sig-name descname"><span class="pre">Kernel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitVarSnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_var_snippets.Kernel" title="Permalink to this definition"></a></dt>
<dd><p>Used to initialise synapse variables from a kernel. This snippet type is used
if you wish to initialise sparse connectivity using a sparse connectivity
initialisation snippet with a kernel such as InitSparseConnectivitySnippet::Conv2D.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_var_snippets.Normal">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_var_snippets.</span></span><span class="sig-name descname"><span class="pre">Normal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitVarSnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_var_snippets.Normal" title="Permalink to this definition"></a></dt>
<dd><p>Initialises variable by sampling from the normal distribution
This snippet takes 2 parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mean</span></code> - The mean</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sd</span></code> - The standard deviation</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_var_snippets.NormalClipped">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_var_snippets.</span></span><span class="sig-name descname"><span class="pre">NormalClipped</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitVarSnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_var_snippets.NormalClipped" title="Permalink to this definition"></a></dt>
<dd><p>Initialises variable by sampling from the normal distribution,
Resamples value if out of range specified my min and max
This snippet takes 2 parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mean</span></code> - The mean</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sd</span></code> - ThGeNN::e standard deviation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min</span></code> - The minimum value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max</span></code> - The maximum value</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_var_snippets.NormalClippedDelay">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_var_snippets.</span></span><span class="sig-name descname"><span class="pre">NormalClippedDelay</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitVarSnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_var_snippets.NormalClippedDelay" title="Permalink to this definition"></a></dt>
<dd><p>Initialises variable by sampling from the normal distribution,
Resamples value of out of range specified my min and max.
This snippet is intended for initializing (dendritic) delay parameters
where parameters are specified in ms but converted to timesteps.
This snippet takes 2 parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mean</span></code> - The mean [ms]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sd</span></code> - The standard deviation [ms]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min</span></code> - The minimum value [ms]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max</span></code> - The maximum value [ms]</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_var_snippets.Uniform">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_var_snippets.</span></span><span class="sig-name descname"><span class="pre">Uniform</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitVarSnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_var_snippets.Uniform" title="Permalink to this definition"></a></dt>
<dd><p>Initialises variable by sampling from the uniform distribution
This snippet takes 2 parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">min</span></code> - The minimum value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max</span></code> - The maximum value</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.init_var_snippets.Uninitialised">
<span class="sig-prename descclassname"><span class="pre">pygenn.init_var_snippets.</span></span><span class="sig-name descname"><span class="pre">Uninitialised</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.InitVarSnippetBase</span></span></span><a class="headerlink" href="#pygenn.init_var_snippets.Uninitialised" title="Permalink to this definition"></a></dt>
<dd><p>Used to mark variables as uninitialised - no initialisation code will be run</p>
</dd></dl>

</section>
<section id="module-pygenn.model_preprocessor">
<span id="pygenn-model-preprocessor-module"></span><h2>pygenn.model_preprocessor module<a class="headerlink" href="#module-pygenn.model_preprocessor" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.Array">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.model_preprocessor.</span></span><span class="sig-name descname"><span class="pre">Array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.Array" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.model_preprocessor.ArrayBase" title="pygenn.model_preprocessor.ArrayBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArrayBase</span></code></a></p>
<p>Array class used for exposing internal GeNN state</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>variable_type</strong> (<em>ResolvedType</em><em> | </em><em>UnresolvedType</em>) – </p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.Array.view">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">view</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#pygenn.model_preprocessor.Array.view" title="Permalink to this definition"></a></dt>
<dd><p>Memory view of array</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.ArrayBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.model_preprocessor.</span></span><span class="sig-name descname"><span class="pre">ArrayBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.ArrayBase" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for classes which access
arrays of memory in running model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable_type</strong> (<em>ResolvedType</em><em> | </em><em>UnresolvedType</em>) – data type of array elements</p></li>
<li><p><strong>group</strong> – group array belongs to</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.ArrayBase.pull_from_device">
<span class="sig-name descname"><span class="pre">pull_from_device</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.ArrayBase.pull_from_device" title="Permalink to this definition"></a></dt>
<dd><p>Copy array device to host</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.ArrayBase.push_to_device">
<span class="sig-name descname"><span class="pre">push_to_device</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.ArrayBase.push_to_device" title="Permalink to this definition"></a></dt>
<dd><p>Copy array from host to device</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.ArrayBase.set_array">
<span class="sig-name descname"><span class="pre">set_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.ArrayBase.set_array" title="Permalink to this definition"></a></dt>
<dd><p>Assign an array obtained from runtime to object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> – array object obtained from runtime</p></li>
<li><p><strong>view_shape</strong> – shape to reshape array with</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.ExtraGlobalParameter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.model_preprocessor.</span></span><span class="sig-name descname"><span class="pre">ExtraGlobalParameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.ExtraGlobalParameter" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.model_preprocessor.Array" title="pygenn.model_preprocessor.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></p>
<p>Array class used for exposing GeNN extra global parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable_name</strong> (<em>str</em>) – name of the extra global parameter</p></li>
<li><p><strong>variable_type</strong> (<em>ResolvedType</em><em> | </em><em>UnresolvedType</em>) – data type of the extra global parameter</p></li>
<li><p><strong>group</strong> – group extra global parameter belongs to</p></li>
<li><p><strong>init_values</strong> – values to initialise extra global parameter with</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.ExtraGlobalParameter.set_init_values">
<span class="sig-name descname"><span class="pre">set_init_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_values</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.ExtraGlobalParameter.set_init_values" title="Permalink to this definition"></a></dt>
<dd><p>Set values extra global parameter is initialised with</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>init_values</strong> – values to initialise extra global parameter with</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.ExtraGlobalParameter.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#pygenn.model_preprocessor.ExtraGlobalParameter.values" title="Permalink to this definition"></a></dt>
<dd><p>Copy of extra global parameter values</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.ExtraGlobalParameter.view">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">view</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#pygenn.model_preprocessor.ExtraGlobalParameter.view" title="Permalink to this definition"></a></dt>
<dd><p>Memory view of extra global parameter</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.SynapseVariable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.model_preprocessor.</span></span><span class="sig-name descname"><span class="pre">SynapseVariable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.SynapseVariable" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.model_preprocessor.VariableBase" title="pygenn.model_preprocessor.VariableBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">VariableBase</span></code></a></p>
<p>Array class used for exposing per-synapse GeNN variables</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable_name</strong> (<em>str</em>) – name of the variable</p></li>
<li><p><strong>variable_type</strong> (<em>ResolvedType</em><em> | </em><em>UnresolvedType</em>) – data type of the variable</p></li>
<li><p><strong>init_values</strong> – values to initialise variable with</p></li>
<li><p><strong>group</strong> – group variable belongs to</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.SynapseVariable.current_values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">current_values</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#pygenn.model_preprocessor.SynapseVariable.current_values" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.SynapseVariable.current_view">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">current_view</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#pygenn.model_preprocessor.SynapseVariable.current_view" title="Permalink to this definition"></a></dt>
<dd><p>Memory view of variable. This operation is not supported for
variables associated with <code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixConnectivity.SPARSE</span></code>
connectivity.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.SynapseVariable.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#pygenn.model_preprocessor.SynapseVariable.values" title="Permalink to this definition"></a></dt>
<dd><p>Copy of variable’s values. Variables associated with
<code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixConnectivity.SPARSE</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.SynapseVariable.view">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">view</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#pygenn.model_preprocessor.SynapseVariable.view" title="Permalink to this definition"></a></dt>
<dd><p>Memory view of variable. This operation is not supported for
variables associated with <code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixConnectivity.SPARSE</span></code>
connectivity.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.Variable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.model_preprocessor.</span></span><span class="sig-name descname"><span class="pre">Variable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.Variable" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.model_preprocessor.VariableBase" title="pygenn.model_preprocessor.VariableBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">VariableBase</span></code></a></p>
<p>Array class used for exposing per-neuron GeNN variables</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable_name</strong> (<em>str</em>) – name of the variable</p></li>
<li><p><strong>variable_type</strong> (<em>ResolvedType</em><em> | </em><em>UnresolvedType</em>) – data type of the variable</p></li>
<li><p><strong>init_values</strong> – values to initialise variable with</p></li>
<li><p><strong>group</strong> – group variable belongs to</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.Variable.current_values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">current_values</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#pygenn.model_preprocessor.Variable.current_values" title="Permalink to this definition"></a></dt>
<dd><p>Copy of variable’s values written in last timestep</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.Variable.current_view">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">current_view</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#pygenn.model_preprocessor.Variable.current_view" title="Permalink to this definition"></a></dt>
<dd><p>Memory view of variable’s values written in last timestep</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.Variable.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#pygenn.model_preprocessor.Variable.values" title="Permalink to this definition"></a></dt>
<dd><p>Copy of entire variable. If variable is
delayed this will contain multiple delayed values.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.Variable.view">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">view</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span></em><a class="headerlink" href="#pygenn.model_preprocessor.Variable.view" title="Permalink to this definition"></a></dt>
<dd><p>Memory view of entire variable. If variable is
delayed this will contain multiple delayed values.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.VariableBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.model_preprocessor.</span></span><span class="sig-name descname"><span class="pre">VariableBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.VariableBase" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pygenn.model_preprocessor.ArrayBase" title="pygenn.model_preprocessor.ArrayBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArrayBase</span></code></a></p>
<p>Base class for arrays used to expose GeNN variables</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable_name</strong> (<em>str</em>) – name of the variable</p></li>
<li><p><strong>variable_type</strong> (<em>ResolvedType</em><em> | </em><em>UnresolvedType</em>) – data type of the variable</p></li>
<li><p><strong>init_values</strong> – values to initialise variable with</p></li>
<li><p><strong>group</strong> – group variable belongs to</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.VariableBase.set_array">
<span class="sig-name descname"><span class="pre">set_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay_group</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.VariableBase.set_array" title="Permalink to this definition"></a></dt>
<dd><p>Assign an array obtained from runtime to object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> – array object obtained from runtime</p></li>
<li><p><strong>view_shape</strong> – shape to reshape array with</p></li>
<li><p><strong>delay_group</strong> – neuron group which defines this array’s delays</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygenn.model_preprocessor.VariableBase.set_init_values">
<span class="sig-name descname"><span class="pre">set_init_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init_values</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.model_preprocessor.VariableBase.set_init_values" title="Permalink to this definition"></a></dt>
<dd><p>Set values variable is initialised with</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>init_values</strong> – values to initialise variable with</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-pygenn.neuron_models">
<span id="pygenn-neuron-models-module"></span><h2>pygenn.neuron_models module<a class="headerlink" href="#module-pygenn.neuron_models" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pygenn.neuron_models.Izhikevich">
<span class="sig-prename descclassname"><span class="pre">pygenn.neuron_models.</span></span><span class="sig-name descname"><span class="pre">Izhikevich</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.NeuronModelBase</span></span></span><a class="headerlink" href="#pygenn.neuron_models.Izhikevich" title="Permalink to this definition"></a></dt>
<dd><p>Izhikevich neuron with fixed parameters  <a class="reference internal" href="../bibliography.html#izhikevich2003" id="id4"><span>[Izhikevich2003]</span></a>.
It is usually described as</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
\frac{dV}{dt} &amp;=&amp; 0.04 V^2 + 5 V + 140 - U + I, \\
\frac{dU}{dt} &amp;=&amp; a (bV-U),
\end{eqnarray*}</div><p>I is an external input current and the voltage V is reset to parameter c and U incremented by parameter d, whenever V &gt;= 30 mV. This is paired with a particular integration procedure of two 0.5 ms Euler time steps for the V equation followed by one 1 ms time step of the U equation. Because of its popularity we provide this model in this form here event though due to the details of the usual implementation it is strictly speaking inconsistent with the displayed equations.</p>
<p>Variables are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code> - Membrane potential</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">U</span></code> - Membrane recovery variable</p></li>
</ul>
<p>Parameters are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> - time scale of U</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> - sensitivity of U</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code> - after-spike reset value of V</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">d</span></code> - after-spike reset value of U</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.neuron_models.IzhikevichVariable">
<span class="sig-prename descclassname"><span class="pre">pygenn.neuron_models.</span></span><span class="sig-name descname"><span class="pre">IzhikevichVariable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.NeuronModelBase</span></span></span><a class="headerlink" href="#pygenn.neuron_models.IzhikevichVariable" title="Permalink to this definition"></a></dt>
<dd><p>Izhikevich neuron with variable parameters  <a class="reference internal" href="../bibliography.html#izhikevich2003" id="id5"><span>[Izhikevich2003]</span></a>.
This is the same model as NeuronModels::Izhikevich but parameters are defined as
“variables” in order to allow users to provide individual values for each
individual neuron instead of fixed values for all neurons across the population.</p>
<p>Accordingly, the model has the variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code> - Membrane potential</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">U</span></code> - Membrane recovery variable</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> - time scale of U</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> - sensitivity of U</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code> - after-spike reset value of V</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">d</span></code> - after-spike reset value of U</p></li>
</ul>
<p>and no parameters.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.neuron_models.LIF">
<span class="sig-prename descclassname"><span class="pre">pygenn.neuron_models.</span></span><span class="sig-name descname"><span class="pre">LIF</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.NeuronModelBase</span></span></span><a class="headerlink" href="#pygenn.neuron_models.LIF" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.neuron_models.Poisson">
<span class="sig-prename descclassname"><span class="pre">pygenn.neuron_models.</span></span><span class="sig-name descname"><span class="pre">Poisson</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.NeuronModelBase</span></span></span><a class="headerlink" href="#pygenn.neuron_models.Poisson" title="Permalink to this definition"></a></dt>
<dd><p>Poisson neurons
This neuron model emits spikes according to the Poisson distribution with a mean firing
rate as determined by its single parameter.
It has 1 state variable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">timeStepToSpike</span></code> - Number of timesteps to next spike</p></li>
</ul>
<p>and 1 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rate</span></code> - Mean firing rate (Hz)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Internally this samples from the exponential distribution using
the C++ 11 &lt;random&gt; library on the CPU and by transforming the
uniform distribution, generated using cuRAND, with a natural log on the GPU.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you are connecting Poisson neurons one-to-one to another neuron population,
it is more efficient to add a CurrentSourceModels::PoissonExp instead.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.neuron_models.RulkovMap">
<span class="sig-prename descclassname"><span class="pre">pygenn.neuron_models.</span></span><span class="sig-name descname"><span class="pre">RulkovMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.NeuronModelBase</span></span></span><a class="headerlink" href="#pygenn.neuron_models.RulkovMap" title="Permalink to this definition"></a></dt>
<dd><p>Rulkov Map neuron
The RulkovMap type is a map based neuron model based on  <a class="reference internal" href="../bibliography.html#rulkov2002" id="id6"><span>[Rulkov2002]</span></a> but in
the 1-dimensional map form used in <a class="reference internal" href="../bibliography.html#nowotny2005" id="id7"><span>[Nowotny2005]</span></a>:</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
V(t+\Delta t) &amp;=&amp; \left\{ \begin{array}{ll}
V_{\rm spike} \Big(\frac{\alpha V_{\rm spike}}{V_{\rm spike}-V(t) \beta I_{\rm syn}} + y \Big) &amp; V(t) \leq 0 \\
V_{\rm spike} \big(\alpha+y\big) &amp; V(t) \leq V_{\rm spike} \big(\alpha + y\big) \; \&amp; \; V(t-\Delta t) \leq 0 \\
-V_{\rm spike} &amp; {\rm otherwise}
\end{array}
\right.
\end{eqnarray*}</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <cite>RulkovMap</cite> type only works as intended for the single time step size of <a href="#id8"><span class="problematic" id="id9">`</span></a>DT`= 0.5.</p>
</div>
<p>The <cite>RulkovMap</cite> type has 2 variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code> - the membrane potential</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">preV</span></code> - the membrane potential at the previous time step</p></li>
</ul>
<p>and it has 4 parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Vspike</span></code> - determines the amplitude of spikes, typically -60mV</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> - determines the shape of the iteration function, typically :math:<a href="#id10"><span class="problematic" id="id11">`</span></a>alpha <a href="#id12"><span class="problematic" id="id13">`</span></a>= 3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> - “shift / excitation” parameter, also determines the iteration function,originally, y= -2.468</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code> - roughly speaking equivalent to the input resistance, i.e. it regulates the scale of the input into the neuron, typically <span class="math notranslate nohighlight">\(\beta`= 2.64 :math:`{\rm M}\Omega\)</span>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The initial values array for the <cite>RulkovMap</cite> type needs two entries for <cite>V</cite> and <cite>preV</cite> and the
parameter array needs four entries for <cite>Vspike</cite>, <cite>alpha</cite>, <cite>y</cite> and <cite>beta</cite>,  <em>in that order</em>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.neuron_models.SpikeSourceArray">
<span class="sig-prename descclassname"><span class="pre">pygenn.neuron_models.</span></span><span class="sig-name descname"><span class="pre">SpikeSourceArray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.NeuronModelBase</span></span></span><a class="headerlink" href="#pygenn.neuron_models.SpikeSourceArray" title="Permalink to this definition"></a></dt>
<dd><p>Spike source array
A neuron which reads spike times from a global spikes array.
It has 2 variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">startSpike</span></code> - Index of the next spike in the global array</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">endSpike</span></code>   - Index of the spike next to the last in the globel array</p></li>
</ul>
<p>and 1 extra global parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">spikeTimes</span></code> - Array with all spike times</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.neuron_models.TraubMiles">
<span class="sig-prename descclassname"><span class="pre">pygenn.neuron_models.</span></span><span class="sig-name descname"><span class="pre">TraubMiles</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.NeuronModelBase</span></span></span><a class="headerlink" href="#pygenn.neuron_models.TraubMiles" title="Permalink to this definition"></a></dt>
<dd><p>Hodgkin-Huxley neurons with Traub &amp; Miles algorithm.
This conductance based model has been taken from  <a class="reference internal" href="../bibliography.html#traub1991" id="id14"><span>[Traub1991]</span></a> and can be described by the equations:</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
C \frac{d V}{dt}  &amp;=&amp; -I_{{\rm Na}} -I_K-I_{{\rm leak}}-I_M-I_{i,DC}-I_{i,{\rm syn}}-I_i, \\
I_{{\rm Na}}(t) &amp;=&amp; g_{{\rm Na}} m_i(t)^3 h_i(t)(V_i(t)-E_{{\rm Na}}) \\
I_{{\rm K}}(t) &amp;=&amp; g_{{\rm K}} n_i(t)^4(V_i(t)-E_{{\rm K}})  \\
\frac{dy(t)}{dt} &amp;=&amp; \alpha_y (V(t))(1-y(t))-\beta_y(V(t)) y(t),
\end{eqnarray*}</div><p>where <span class="math notranslate nohighlight">\(y_i= m, h, n\)</span>, and</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
\alpha_n&amp;=&amp; 0.032(-50-V)/\big(\exp((-50-V)/5)-1\big)  \\
\beta_n &amp;=&amp; 0.5\exp((-55-V)/40)  \\
\alpha_m &amp;=&amp; 0.32(-52-V)/\big(\exp((-52-V)/4)-1\big)  \\
\beta_m &amp;=&amp; 0.28(25+V)/\big(\exp((25+V)/5)-1\big)  \\
\alpha_h &amp;=&amp; 0.128\exp((-48-V)/18)  \\
\beta_h &amp;=&amp; 4/\big(\exp((-25-V)/5)+1\big).
\end{eqnarray*}</div><p>and typical parameters are <span class="math notranslate nohighlight">\(C=0.143\)</span> nF, <span class="math notranslate nohighlight">\(g_{{\rm leak}}= 0.02672\)</span>
<span class="math notranslate nohighlight">\(\mu`S, :math:`E_{{\rm leak}}= -63.563\)</span> mV, <span class="math notranslate nohighlight">\(g_{{\rm Na}}=7.15\)</span> <span class="math notranslate nohighlight">\(\mu`S,
:math:`E_{{\rm Na}}= 50\)</span> mV, <span class="math notranslate nohighlight">\(g_{{\rm {\rm K}}}=1.43\)</span> <span class="math notranslate nohighlight">\(\mu`S,
:math:`E_{{\rm K}}= -95\)</span> mV.</p>
<p>It has 4 variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code> - membrane potential E</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m</span></code> - probability for Na channel activation m</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">h</span></code> - probability for not Na channel blocking h</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> - probability for K channel activation n</p></li>
</ul>
<p>and 7 parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gNa</span></code> - Na conductance in 1/(mOhms * cm^2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENa</span></code> - Na equi potential in mV</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gK</span></code> - K conductance in 1/(mOhms * cm^2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EK</span></code> - K equi potential in mV</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gl</span></code> - Leak conductance in 1/(mOhms * cm^2)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">El</span></code> - Leak equi potential in mV</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code> - Membrane capacity density in muF/cm^2</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Internally, the ordinary differential equations defining the model are integrated with a
linear Euler algorithm and GeNN integrates 25 internal time steps for each neuron for each
network time step. I.e., if the network is simulated at <cite>DT= 0.1</cite> ms, then the neurons are
integrated with a linear Euler algorithm with <cite>lDT= 0.004</cite> ms.
This variant uses IF statements to check for a value at which a singularity would be hit.
If so, value calculated by L’Hospital rule is used.</p>
</div>
</dd></dl>

</section>
<section id="module-pygenn.postsynaptic_models">
<span id="pygenn-postsynaptic-models-module"></span><h2>pygenn.postsynaptic_models module<a class="headerlink" href="#module-pygenn.postsynaptic_models" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pygenn.postsynaptic_models.DeltaCurr">
<span class="sig-prename descclassname"><span class="pre">pygenn.postsynaptic_models.</span></span><span class="sig-name descname"><span class="pre">DeltaCurr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.PostsynapticModelBase</span></span></span><a class="headerlink" href="#pygenn.postsynaptic_models.DeltaCurr" title="Permalink to this definition"></a></dt>
<dd><p>Simple delta current synapse.
Synaptic input provides a direct inject of instantaneous current</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.postsynaptic_models.ExpCond">
<span class="sig-prename descclassname"><span class="pre">pygenn.postsynaptic_models.</span></span><span class="sig-name descname"><span class="pre">ExpCond</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.PostsynapticModelBase</span></span></span><a class="headerlink" href="#pygenn.postsynaptic_models.ExpCond" title="Permalink to this definition"></a></dt>
<dd><p>Exponential decay with synaptic input treated as a conductance value.
This model has no variables, two parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tau</span></code> - Decay time constant</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">E</span></code> - Reversal potential</p></li>
</ul>
<p>and a variable reference:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code> - A reference to the neuron’s membrane voltage</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">tau</span></code> is used by the derived parameter <code class="docutils literal notranslate"><span class="pre">expdecay</span></code> which returns expf(-dt/tau).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.postsynaptic_models.ExpCurr">
<span class="sig-prename descclassname"><span class="pre">pygenn.postsynaptic_models.</span></span><span class="sig-name descname"><span class="pre">ExpCurr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.PostsynapticModelBase</span></span></span><a class="headerlink" href="#pygenn.postsynaptic_models.ExpCurr" title="Permalink to this definition"></a></dt>
<dd><p>Exponential decay with synaptic input treated as a current value.
This model has no variables and a single parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tau</span></code> - Decay time constant</p></li>
</ul>
</dd></dl>

</section>
<section id="module-pygenn.single_threaded_cpu_backend">
<span id="pygenn-single-threaded-cpu-backend-module"></span><h2>pygenn.single_threaded_cpu_backend module<a class="headerlink" href="#module-pygenn.single_threaded_cpu_backend" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pygenn.single_threaded_cpu_backend.Preferences">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.single_threaded_cpu_backend.</span></span><span class="sig-name descname"><span class="pre">Preferences</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pygenn.single_threaded_cpu_backend.Preferences" title="pygenn.single_threaded_cpu_backend.Preferences"><span class="pre">pygenn.single_threaded_cpu_backend.Preferences</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygenn.single_threaded_cpu_backend.Preferences" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">PreferencesBase</span></code></p>
</dd></dl>

</section>
<section id="module-pygenn.types">
<span id="pygenn-types-module"></span><h2>pygenn.types module<a class="headerlink" href="#module-pygenn.types" title="Permalink to this heading"></a></h2>
</section>
<section id="module-pygenn.weight_update_models">
<span id="pygenn-weight-update-models-module"></span><h2>pygenn.weight_update_models module<a class="headerlink" href="#module-pygenn.weight_update_models" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pygenn.weight_update_models.STDP">
<span class="sig-prename descclassname"><span class="pre">pygenn.weight_update_models.</span></span><span class="sig-name descname"><span class="pre">STDP</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.WeightUpdateModelBase</span></span></span><a class="headerlink" href="#pygenn.weight_update_models.STDP" title="Permalink to this definition"></a></dt>
<dd><p>Simply asymmetrical STDP rule.
This rule makes purely additive weight updates within hard bounds and uses nearest-neighbour spike pairing and the following time-dependence:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\Delta w_{ij} = \
\begin{cases}
A_{+}\exp\left(-\frac{\Delta t}{\tau_{+}}\right) &amp; if\, \Delta t&gt;0\\
A_{-}\exp\left(\frac{\Delta t}{\tau_{-}}\right) &amp; if\, \Delta t\leq0
\end{cases}\end{split}\]</div>
<p>The model has 1 variable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> - synaptic weight</p></li>
</ul>
<p>and 6 parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tauPlus</span></code> - Potentiation time constant (ms)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tauMinus</span></code> - Depression time constant (ms)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Aplus</span></code> - Rate of potentiation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Aminus</span></code> - Rate of depression</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Wmin</span></code> - Minimum weight</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Wmax</span></code> - Maximum weight</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.weight_update_models.StaticGraded">
<span class="sig-prename descclassname"><span class="pre">pygenn.weight_update_models.</span></span><span class="sig-name descname"><span class="pre">StaticGraded</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.WeightUpdateModelBase</span></span></span><a class="headerlink" href="#pygenn.weight_update_models.StaticGraded" title="Permalink to this definition"></a></dt>
<dd><p>Graded-potential, static synapse
In a graded synapse, the conductance is updated gradually with the rule:</p>
<div class="math notranslate nohighlight">
\[gSyn= g * tanh((V - E_{pre}) / V_{slope}\]</div>
<p>whenever the membrane potential <span class="math notranslate nohighlight">\(V\)</span> is larger than the threshold <span class="math notranslate nohighlight">\(E_{pre}\)</span>.
The model has 1 variable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> - synaptic weight</p></li>
</ul>
<p>The model also has 1 presynaptic neuron variable reference:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code> - Presynaptic membrane potential</p></li>
</ul>
<p>The parameters are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Epre</span></code> - Presynaptic threshold potential</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Vslope</span></code> - Activation slope of graded release</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.weight_update_models.StaticPulse">
<span class="sig-prename descclassname"><span class="pre">pygenn.weight_update_models.</span></span><span class="sig-name descname"><span class="pre">StaticPulse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.WeightUpdateModelBase</span></span></span><a class="headerlink" href="#pygenn.weight_update_models.StaticPulse" title="Permalink to this definition"></a></dt>
<dd><p>Pulse-coupled, static synapse with heterogeneous weight.
No learning rule is applied to the synapse and for each pre-synaptic spikes,
the synaptic conductances are simply added to the postsynaptic input variable.
The model has 1 variable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> - synaptic weight</p></li>
</ul>
<p>and no other parameters.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.weight_update_models.StaticPulseConstantWeight">
<span class="sig-prename descclassname"><span class="pre">pygenn.weight_update_models.</span></span><span class="sig-name descname"><span class="pre">StaticPulseConstantWeight</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.WeightUpdateModelBase</span></span></span><a class="headerlink" href="#pygenn.weight_update_models.StaticPulseConstantWeight" title="Permalink to this definition"></a></dt>
<dd><p>Pulse-coupled, static synapse with homogeneous weight.
No learning rule is applied to the synapse and for each pre-synaptic spikes,
the synaptic conductances are simply added to the postsynaptic input variable.
The model has 1 parameter:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> - synaptic weight</p></li>
</ul>
<p>and no other variables.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pygenn.weight_update_models.StaticPulseDendriticDelay">
<span class="sig-prename descclassname"><span class="pre">pygenn.weight_update_models.</span></span><span class="sig-name descname"><span class="pre">StaticPulseDendriticDelay</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pygenn._genn.WeightUpdateModelBase</span></span></span><a class="headerlink" href="#pygenn.weight_update_models.StaticPulseDendriticDelay" title="Permalink to this definition"></a></dt>
<dd><p>Pulse-coupled, static synapse with heterogenous weight and dendritic delays
No learning rule is applied to the synapse and for each pre-synaptic spikes,
the synaptic conductances are simply added to the postsynaptic input variable.
The model has 2 variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> - synaptic weight</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">d</span></code> - dendritic delay in timesteps</p></li>
</ul>
<p>and no other parameters.</p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../userproject/superspike_demo.html" class="btn btn-neutral float-left" title="PyGeNN implementation of SuperSpike" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, James Knight, Thomas Nowotny.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>