<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Custom models &mdash; PyGeNN  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Bibliography" href="bibliography.html" />
    <link rel="prev" title="Simulating networks" href="simulating_networks.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PyGeNN
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="upgrading.html">Upgrading from GeNN 4</a></li>
<li class="toctree-l1"><a class="reference internal" href="building_networks.html">Building networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulating_networks.html">Simulating networks</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Custom models</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="userproject/index.html">User projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="source/pygenn.html">Reference documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyGeNN</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Custom models</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/custom_models.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="custom-models">
<h1>Custom models<a class="headerlink" href="#custom-models" title="Permalink to this heading"></a></h1>
<p>One of the main things that makes GeNN different from other SNN simulators is that all the
models and snippets  used to describe the behaviour of your model (see <a class="reference internal" href="building_networks.html#section-building-networks"><span class="std std-ref">Building networks</span></a>)
can be easily customised by the user using strings containing a C-like language called GeNNCode.</p>
<section id="genncode">
<h2>GeNNCode<a class="headerlink" href="#genncode" title="Permalink to this heading"></a></h2>
<p>GeNN model functionality is implemented using strings of C-like code which we call GeNNCode.
This is essentially C99 (<a class="reference external" href="https://en.cppreference.com/w/c/language">https://en.cppreference.com/w/c/language</a>) with the following differences:</p>
<ul class="simple">
<li><p>No preprocessor</p></li>
<li><p>Enough support for strings to printf debug messages but not much more i.e. no <code class="docutils literal notranslate"><span class="pre">strstr</span></code> etc.</p></li>
<li><p>Functions, typedefines and structures cannot be defined in user code</p></li>
<li><p>Structures are not supported at all</p></li>
<li><p>Some esoteric C99 language features like octal integer and hexadecimal floating point literals aren’t supported</p></li>
<li><p>The address of (&amp;) operator isn’t supported. On the GPU hardware GeNN targets, local variables are assumed to be stored in registers and not addressable. The only time this is limiting is when dealing with extra global parameter arrays as you can no longer do something like <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">*egpSubset</span> <span class="pre">=</span> <span class="pre">&amp;egp[offset];</span></code> and instead have to do <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">*egpSubset</span> <span class="pre">=</span> <span class="pre">egp</span> <span class="pre">+</span> <span class="pre">offset;</span></code>.</p></li>
<li><p>Like C++ (but not C99) function overloading is supported so <code class="docutils literal notranslate"><span class="pre">sin(30.0f)</span></code> will resolve to the floating point rather than double-precision version.</p></li>
<li><p>Floating point literals like <code class="docutils literal notranslate"><span class="pre">30.0</span></code> without a suffix will be treated as <code class="docutils literal notranslate"><span class="pre">scalar</span></code> (i.e. the floating point type declared as the precision of the overall model), <code class="docutils literal notranslate"><span class="pre">30.0f</span></code> will always be treated as float and <code class="docutils literal notranslate"><span class="pre">30.0d</span></code> will always be treated as double.</p></li>
<li><p>An LP64 data model is used on all platforms where <code class="docutils literal notranslate"><span class="pre">int</span></code> is 32-bit and <code class="docutils literal notranslate"><span class="pre">long</span></code> is 64-bit.</p></li>
<li><p>Only the following standard library functions are supported: <code class="docutils literal notranslate"><span class="pre">cos</span></code>, <code class="docutils literal notranslate"><span class="pre">sin</span></code>, <code class="docutils literal notranslate"><span class="pre">tan</span></code>, <code class="docutils literal notranslate"><span class="pre">acos</span></code>, <code class="docutils literal notranslate"><span class="pre">asin</span></code>, <code class="docutils literal notranslate"><span class="pre">atan</span></code>, <code class="docutils literal notranslate"><span class="pre">atan2</span></code>, <code class="docutils literal notranslate"><span class="pre">cosh</span></code>, <code class="docutils literal notranslate"><span class="pre">sinh</span></code>, <code class="docutils literal notranslate"><span class="pre">tanh</span></code>, <code class="docutils literal notranslate"><span class="pre">acosh</span></code>, <code class="docutils literal notranslate"><span class="pre">asinh</span></code>, <code class="docutils literal notranslate"><span class="pre">atanh</span></code>, <code class="docutils literal notranslate"><span class="pre">exp</span></code>, <code class="docutils literal notranslate"><span class="pre">expm1</span></code>, <code class="docutils literal notranslate"><span class="pre">exp2</span></code>, <code class="docutils literal notranslate"><span class="pre">pow</span></code>, <code class="docutils literal notranslate"><span class="pre">scalbn</span></code>, <code class="docutils literal notranslate"><span class="pre">log</span></code>, <code class="docutils literal notranslate"><span class="pre">log1p</span></code>, <code class="docutils literal notranslate"><span class="pre">log2</span></code>, <code class="docutils literal notranslate"><span class="pre">log10</span></code>, <code class="docutils literal notranslate"><span class="pre">ldexp</span></code>, <code class="docutils literal notranslate"><span class="pre">ilogb</span></code>, <code class="docutils literal notranslate"><span class="pre">sqrt</span></code>, <code class="docutils literal notranslate"><span class="pre">cbrt</span></code>, <code class="docutils literal notranslate"><span class="pre">hypot</span></code>, <code class="docutils literal notranslate"><span class="pre">ceil</span></code>, <code class="docutils literal notranslate"><span class="pre">floor</span></code>, <code class="docutils literal notranslate"><span class="pre">fmod</span></code>, <code class="docutils literal notranslate"><span class="pre">round</span></code>, <code class="docutils literal notranslate"><span class="pre">rint</span></code>, <code class="docutils literal notranslate"><span class="pre">trunc</span></code>, <code class="docutils literal notranslate"><span class="pre">nearbyint</span></code>, <code class="docutils literal notranslate"><span class="pre">nextafter</span></code>, <code class="docutils literal notranslate"><span class="pre">remainder</span></code>, <code class="docutils literal notranslate"><span class="pre">fabs</span></code>, <code class="docutils literal notranslate"><span class="pre">fdim</span></code>, <code class="docutils literal notranslate"><span class="pre">fmax</span></code>, <code class="docutils literal notranslate"><span class="pre">fmin</span></code>, <code class="docutils literal notranslate"><span class="pre">erf</span></code>, <code class="docutils literal notranslate"><span class="pre">erfc</span></code>, <code class="docutils literal notranslate"><span class="pre">tgamma</span></code>, <code class="docutils literal notranslate"><span class="pre">lgamma</span></code>, <code class="docutils literal notranslate"><span class="pre">copysign</span></code>, <code class="docutils literal notranslate"><span class="pre">fma</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">abs</span></code>, <code class="docutils literal notranslate"><span class="pre">printf</span></code></p></li>
</ul>
<section id="random-number-generation">
<h3>Random number generation<a class="headerlink" href="#random-number-generation" title="Permalink to this heading"></a></h3>
<p>Random numbers are useful in many forms of custom model, for example as a source of noise or a probabilistic spiking mechanism.
In GeNN this can be implemented by using the following functions within GeNNCode:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gennrand()</span></code> returns a random 32-bit unsigned integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gennrand_uniform()</span></code> returns a number drawn uniformly from the interval <span class="math notranslate nohighlight">\([0.0, 1.0]\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gennrand_normal()</span></code> returns a number drawn from a normal distribution with a mean of 0 and a standard deviation of 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gennrand_exponential()</span></code> returns a number drawn from an exponential distribution with <span class="math notranslate nohighlight">\(\lambda=1\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gennrand_log_normal(mean,</span> <span class="pre">std)</span></code> returns a number drawn from a log-normal distribution with the specified mean and standard deviation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gennrand_gamma(alpha)</span></code> returns a number drawn from a gamma distribution with the specified shape.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gennrand_binomial(n,</span> <span class="pre">p)</span></code> returns a number drawn from a binomial distribution with the specified shape.</p></li>
</ul>
</section>
</section>
<section id="initialisation-snippets">
<h2>Initialisation snippets<a class="headerlink" href="#initialisation-snippets" title="Permalink to this heading"></a></h2>
<p>Initialisation snippets are GeNNCode to initialise various parts of a GeNN model.
They are configurable by the user with parameters, derived parameters and extra global parameters.
Parameters have a homogeneous numeric value across the population being initialised.
‘Derived parameters’ are a mechanism for enhanced efficiency when running neuron models.
They allow constants used within the GeNNCode implementation of a model to be computed
from more ‘user friendly’ parameters provided by the user. For example, a decay to apply
each timestep could be computed from a time constant provided in a parameter called <code class="docutils literal notranslate"><span class="pre">tau</span></code>
by passing the following keyword arguments to one of the snippet or model creation functions described below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">],</span>
<span class="n">derived_params</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;ExpTC&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">pars</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dt</span> <span class="o">/</span> <span class="n">pars</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]))])</span>
</pre></div>
</div>
<section id="variable-initialisation">
<h3>Variable initialisation<a class="headerlink" href="#variable-initialisation" title="Permalink to this heading"></a></h3>
<p>New variable initialisation snippets can be defined by calling:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_var_init_snippet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_init_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new variable initialisation snippet.
Within the <code class="docutils literal notranslate"><span class="pre">var_init_code</span></code>, the parameters, derived parameters and
extra global parameters defined in this snippet can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
</ul>
<p>And, if the snippet is used to initialise a per-neuron variable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code> which represents a neurons index within a population (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_neurons</span></code> which represents the number of neurons in the population</p></li>
</ul>
<p>or, a per-synapse variable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id_pre</span></code> which represents the index of the presynaptic neuron (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id_post</span></code> which represents the index of the postsynaptic neuron (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pre</span></code> which represents the number of presynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_post</span></code> which represents the number of postsynaptic neurons</p></li>
</ul>
<p>Finally, the variable being initialised is represented by
the write-only <code class="docutils literal notranslate"><span class="pre">value</span></code> variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new model (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from paramss</p></li>
<li><p><strong>var_init_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the code statements
required to initialise the variable</p></li>
<li><p><strong>extra_global_params</strong> – names and types of model
extra global parameters</p></li>
</ul>
</dd>
</dl>
<p>For example, if we wanted to define a snippet to initialise variables by sampling from a normal distribution,
redrawing if the value is negative (which could be useful to ensure delays remain causal):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">normal_positive_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_var_init_snippet</span><span class="p">(</span>
    <span class="s1">&#39;normal_positive&#39;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">],</span>
    <span class="n">var_init_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        scalar normal;</span>
<span class="sd">        do {</span>
<span class="sd">            normal = mean + (gennrand_normal() * sd);</span>
<span class="sd">        } while (normal &lt; 0.0);</span>
<span class="sd">        value = normal;</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="sparse-connectivity-initialisation">
<h3>Sparse connectivity initialisation<a class="headerlink" href="#sparse-connectivity-initialisation" title="Permalink to this heading"></a></h3>
<p>Sparse connectivity initialisation snippets can be used to initialise connectivity when using
<a class="reference internal" href="source/pygenn.html#pygenn.SynapseMatrixType.SPARSE" title="pygenn.SynapseMatrixType.SPARSE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixType.SPARSE</span></code></a> or <a class="reference internal" href="source/pygenn.html#pygenn.SynapseMatrixType.BITMASK" title="pygenn.SynapseMatrixType.BITMASK"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixType.BITMASK</span></code></a> connectivity; and to
generate connectivity on the fly when using <a class="reference internal" href="source/pygenn.html#pygenn.SynapseMatrixType.PROCEDURAL" title="pygenn.SynapseMatrixType.PROCEDURAL"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixType.PROCEDURAL</span></code></a> connectivity.
New sparse connectivity initialisation snippets can be defined by calling:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_sparse_connect_init_snippet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_build_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_build_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_max_row_len_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_max_col_len_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_kernel_size_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new sparse connectivity initialisation snippet.
Within the code strings, the parameters, derived parameters and
extra global parameters defined in this snippet can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pre</span></code> which represents the number of presynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_post</span></code> which represents the number of postsynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thread</span></code> when some procedural connectivity is used with multiple
threads per presynaptic neuron, represents the index of the current thread</p></li>
</ul>
<p>and, in <code class="docutils literal notranslate"><span class="pre">row_build_code</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id_pre</span></code> represents the index of the presynaptic neuron (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id_post_begin</span></code> when some procedural connectivity is used with multiple
threads per presynaptic neuron, represents the index of the first postsynaptic neuron to connect.</p></li>
</ul>
<p>and, in <code class="docutils literal notranslate"><span class="pre">col_build_code</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id_post</span></code> which represents the index of the postsynaptic neuron (starting from zero).</p></li>
</ul>
<p>Finally, the function <code class="docutils literal notranslate"><span class="pre">addSynapse(x)</span></code> can be used to add a new synapse to the connectivity
where, in <code class="docutils literal notranslate"><span class="pre">row_build_code</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is the index of the postsynaptic neuron to connect <code class="docutils literal notranslate"><span class="pre">id_pre</span></code> to
and, in <code class="docutils literal notranslate"><span class="pre">col_build_code</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is the index of the presynaptic neuron to connect to <code class="docutils literal notranslate"><span class="pre">id_post</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the snippet (only for debugging)</p></li>
<li><p><strong>params</strong> – name and optional types of model parameters</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from paramss</p></li>
<li><p><strong>row_build_code</strong> (<em>str</em><em> | </em><em>None</em>) – code for building connectivity row by row</p></li>
<li><p><strong>col_build_code</strong> (<em>str</em><em> | </em><em>None</em>) – code for building connectivity column by column</p></li>
<li><p><strong>calc_max_row_len_func</strong> (<em>Callable</em><em> | </em><em>None</em>) – used to calculate the maximum
row length of the synaptic matrix created using this snippet</p></li>
<li><p><strong>calc_max_col_len_func</strong> (<em>Callable</em><em> | </em><em>None</em>) – used to calculate the maximum
column length of the synaptic matrix created using this snippet</p></li>
<li><p><strong>calc_kernel_size_func</strong> (<em>Callable</em><em> | </em><em>None</em>) – used to calculate the size of the kernel if snippet requires one</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of snippet extra global parameters</p></li>
<li><p><strong>param_names</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
</ul>
</dd>
</dl>
<p>For example, if we wanted to define a snippet to initialise connectivity where each
presynaptic neuron targets a fixed number of postsynaptic neurons, sampled uniformly
with replacement, we could define a snippet as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">binom</span>

<span class="n">fixed_number_post</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_sparse_connect_init_snippet</span><span class="p">(</span>
    <span class="s2">&quot;fixed_number_post&quot;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;num&quot;</span><span class="p">,</span> <span class="s2">&quot;unsigned int&quot;</span><span class="p">)],</span>
    <span class="n">row_build_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for(unsigned int c = num; c != 0; c--) {</span>
<span class="sd">            const unsigned int idPost = gennrand() % num_post;</span>
<span class="sd">            addSynapse(idPost + id_post_begin);</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">calc_max_row_len_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">num_pre</span><span class="p">,</span> <span class="n">num_post</span><span class="p">,</span> <span class="n">pars</span><span class="p">:</span> <span class="n">pars</span><span class="p">[</span><span class="s2">&quot;num&quot;</span><span class="p">],</span>
    <span class="n">calc_max_col_len_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">num_pre</span><span class="p">,</span> <span class="n">num_post</span><span class="p">,</span> <span class="n">pars</span><span class="p">:</span> <span class="n">binom</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.9999</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_post</span><span class="p">),</span>
                                                                    <span class="n">pars</span><span class="p">[</span><span class="s2">&quot;num&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_pre</span><span class="p">,</span>
                                                                    <span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_post</span><span class="p">))</span>
</pre></div>
</div>
<p>For full details of how maximum column lengths are calculated, you should refer to our paper <a class="reference internal" href="bibliography.html#knight2018" id="id1"><span>[Knight2018]</span></a> but,
in short, the number of connections that end up in a column are distributed binomially with <span class="math notranslate nohighlight">\(n=\text{num}\)</span> and <span class="math notranslate nohighlight">\(p=\frac{1}{\text{num_post}}\)</span>
Therefore, we can calculate the maximum column length by looking at the inverse cummulative distribution function (CDF) for the binomial distribution,
looking at the point in the inverse CDF where there is a 0.9999 chance of the bound being correct when drawing synapses from <code class="docutils literal notranslate"><span class="pre">num_post</span></code> columns.</p>
</dd></dl>

</section>
<section id="toeplitz-connectivity-initialisation">
<h3>Toeplitz connectivity initialisation<a class="headerlink" href="#toeplitz-connectivity-initialisation" title="Permalink to this heading"></a></h3>
<p>Toeplitz connectivity initialisation snippets are used to generate convolution-like connectivity
on the fly when using <a class="reference internal" href="source/pygenn.html#pygenn.SynapseMatrixType.TOEPLITZ" title="pygenn.SynapseMatrixType.TOEPLITZ"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseMatrixType.TOEPLITZ</span></code></a> connectivity.
New Toeplitz connectivity initialisation snippets can be defined by calling:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_toeplitz_connect_init_snippet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagonal_build_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_max_row_len_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_kernel_size_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new Toeplitz connectivity initialisation snippet.
Each <em>diagonal</em> of Toeplitz connectivity is initialised independently by running the
snippet of code specified using the <code class="docutils literal notranslate"><span class="pre">diagonal_build_code</span></code>.
Within the code strings, the parameters, derived parameters and
extra global parameters defined in this snippet can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pre</span></code> which represents the number of presynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_post</span></code> which represents the number of postsynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id_diag</span></code> when some procedural connectivity is used with multiple threads</p></li>
</ul>
<p>Additionally, the function <code class="docutils literal notranslate"><span class="pre">addSynapse(id_post,</span> <span class="pre">id_kern_0,</span> <span class="pre">id_kern_1,</span> <span class="pre">...,</span> <span class="pre">id_kern_N)</span></code>
can be used to generate a new synapse to postsynaptic neuron <code class="docutils literal notranslate"><span class="pre">id_post</span></code> using
N-dimensional kernel variables indexed with <code class="docutils literal notranslate"><span class="pre">id_kern_0,</span> <span class="pre">id_kern_1,</span> <span class="pre">...,</span> <span class="pre">id_kern_N</span></code>.
Finally the <code class="docutils literal notranslate"><span class="pre">for_each_synapse{}</span></code> construct can be used to loop through incoming spikes
and, inside this, <code class="docutils literal notranslate"><span class="pre">id_pre</span></code> will represent the index of the spiking presynaptic neuron.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the snippet (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from paramss</p></li>
<li><p><strong>diagonal_build_code</strong> (<em>str</em><em> | </em><em>None</em>) – code for building connectivity row by row</p></li>
<li><p><strong>calc_max_row_len_func</strong> (<em>Callable</em><em> | </em><em>None</em>) – used to calculate the maximum
row length of synaptic matrix created using this snippet</p></li>
<li><p><strong>calc_kernel_size_func</strong> (<em>Callable</em><em> | </em><em>None</em>) – used to calculate the size of the kernel</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of snippet extra global parameters</p></li>
</ul>
</dd>
</dl>
<p>For example, the following Toeplitz connectivity initialisation snippet could be used to
convolve a <span class="math notranslate nohighlight">\(\text{kern_dim} \times \text{kern_dim}\)</span> square kernel with the spikes from a population of <span class="math notranslate nohighlight">\(\text{pop_dim} \times \text{pop_dim}\)</span> neurons.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">simple_conv2d_model</span> <span class="o">=</span> <span class="n">pynn</span><span class="o">.</span><span class="n">create_toeplitz_connect_init_snippet</span><span class="p">(</span>
    <span class="s2">&quot;simple_conv2d&quot;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;kern_size&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pop_dim&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">)],</span>
    <span class="n">diagonal_build_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        const int kernRow = id_diag / kern_dim;</span>
<span class="sd">        const int kernCol = id_diag % kern_dim;</span>

<span class="sd">        for_each_synapse {</span>
<span class="sd">            const int preRow = id_pre / pop_dim;</span>
<span class="sd">            const int preCol = id_pre % pop_dim;</span>
<span class="sd">            // If we haven&#39;t gone off edge of output</span>
<span class="sd">            const int postRow = preRow + kernRow - 1;</span>
<span class="sd">            const int postCol = preCol + kernCol - 1;</span>
<span class="sd">            if(postRow &gt;= 0 &amp;&amp; postCol &gt;= 0 &amp;&amp; postRow &lt; pop_dim &amp;&amp; postCol &lt; pop_dim) {</span>
<span class="sd">                // Calculate postsynaptic index</span>
<span class="sd">                const int postInd = (postRow * pop_dim) + postCol;</span>
<span class="sd">                addSynapse(postInd,  kernRow, kernCol);</span>
<span class="sd">            }</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>

    <span class="n">calc_max_row_len_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">num_pre</span><span class="p">,</span> <span class="n">num_post</span><span class="p">,</span> <span class="n">pars</span><span class="p">:</span> <span class="n">pars</span><span class="p">[</span><span class="s2">&quot;kern_size&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">pars</span><span class="p">[</span><span class="s2">&quot;kern_size&quot;</span><span class="p">],</span>
    <span class="n">calc_kernel_size_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pars</span><span class="p">:</span> <span class="p">[</span><span class="n">pars</span><span class="p">[</span><span class="s2">&quot;kern_size&quot;</span><span class="p">],</span> <span class="n">pars</span><span class="p">[</span><span class="s2">&quot;kern_size&quot;</span><span class="p">]])</span>
</pre></div>
</div>
<p>For full details of how convolution-like connectivity is expressed in this way, please see our paper <a class="reference internal" href="bibliography.html#turner2022" id="id2"><span>[Turner2022]</span></a>.</p>
</dd></dl>

</section>
</section>
<section id="models">
<h2>Models<a class="headerlink" href="#models" title="Permalink to this heading"></a></h2>
<p>Models extend the snippets described above by adding state.
They are used to define the behaviour of neurons, synapses and custom updates.</p>
<section id="variable-access">
<h3>Variable access<a class="headerlink" href="#variable-access" title="Permalink to this heading"></a></h3>
<p>When defining custom models intended to work in batched simulations, it is important to
consider the ‘variable access’ of state variables which determines if they can contain
different values in each batch or whether the same values are shared between batches.
Because simulations are assumed to run in parallel, if variables are shared they must be
be read-only.
Therefore the following modes are available for variables defined in neuron, weight update,
current source and custom connectivity update models:</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">VarAccess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="source/pygenn.html#pygenn.VarAccess" title="pygenn._genn.VarAccess"><span class="pre">pygenn._genn.VarAccess</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Supported combinations of access mode and dimension for neuron and synapse variables</p>
<p>Members:</p>
<blockquote>
<div><p>READ_WRITE : This variable can be read from and written to and stores separate values for each element and each batch</p>
<p>READ_ONLY : This variable can only be read from and stores separate values for each element but these are shared across batches</p>
<p>READ_ONLY_DUPLICATE : This variable can only be read from and stores separate values for each element and each batch</p>
<p>READ_ONLY_SHARED_NEURON : This variable can only be read from and stores separate values for each batch but these are shared across neurons</p>
</div></blockquote>
</dd></dl>

<p>The situation is further complicated when considering custom update models as not
only do these support operations such as reductions but whether the update itself
is batched or not depends on the types of variables it is attached to via
its variable references. Therefore, so that custom update models can be re-used in
different circumstances, their variables can have the following modes:</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">CustomUpdateVarAccess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="source/pygenn.html#pygenn.CustomUpdateVarAccess" title="pygenn._genn.CustomUpdateVarAccess"><span class="pre">pygenn._genn.CustomUpdateVarAccess</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Supported combinations of access mode and dimension for custom update variables.
The axes are defined ‘subtractively’, i.e. VarAccessDim::BATCH indicates that this axis should be removed.</p>
<p>Members:</p>
<blockquote>
<div><p>READ_WRITE : This variable can be read from and written to and has the same dimensions as whatever the custom update is attached to</p>
<p>READ_ONLY : This variable can only be read from and has the same dimensions as whatever the custom update is attached to</p>
<p>READ_ONLY_SHARED : This variable can only be read from and has the same dimensions as whatever</p>
</div></blockquote>
<p>the custom update is attached to aside from being shared across batches</p>
<blockquote>
<div><p>READ_ONLY_SHARED_NEURON : This variable can only be read from and has the same dimensions as whatever</p>
</div></blockquote>
<p>the custom update is attached to aside from being shared across neurons</p>
<blockquote>
<div><p>REDUCE_BATCH_SUM : This variable is a target for a reduction across batches using a sum operation</p>
<p>REDUCE_BATCH_MAX : This variable is a target for a reduction across batches using a max operation</p>
<p>REDUCE_NEURON_SUM : This variable is a target for a reduction across neurons using a sum operation</p>
<p>REDUCE_NEURON_MAX : This variable is a target for a reduction across neurons using a max operation</p>
</div></blockquote>
</dd></dl>

</section>
<section id="neuron-models">
<span id="section-neuron-models"></span><h3>Neuron models<a class="headerlink" href="#neuron-models" title="Permalink to this heading"></a></h3>
<p>Neuron models define the dynamics and spiking behaviour of populations of neurons.
New neuron models are defined by calling:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_neuron_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_condition_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reset_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_input_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auto_refractory_required</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new neuron model.
Within all of the code strings, the variables, parameters,
derived parameters, additional input variables and extra global
parameters defined in this model can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Isyn</span></code> which represents the total incoming synaptic input.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code> which represents a neurons index within a population (starting from zero).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_neurons</span></code> which represents the number of neurons in the population.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of model variables</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>sim_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the simulation code
statements to be run every timestep</p></li>
<li><p><strong>threshold_condition_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing a threshold condition
expression to test whether a spike
should be emitted</p></li>
<li><p><strong>reset_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the reset code
statements to run after emitting a spike</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of model
extra global parameters</p></li>
<li><p><strong>additional_input_vars</strong> – list of tuples with names and types as
strings and initial values of additional
local input variables</p></li>
<li><p><strong>auto_refractory_required</strong> (<em>bool</em>) – does this model require auto-refractory
logic to be generated?</p></li>
</ul>
</dd>
</dl>
<p>For example, we can define a leaky integrator <span class="math notranslate nohighlight">\(\tau\frac{dV}{dt}= -V + I_{{\rm syn}}\)</span> solved using Euler’s method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">leaky_integrator_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_neuron_model</span><span class="p">(</span>
    <span class="s2">&quot;leaky_integrator&quot;</span><span class="p">,</span>

    <span class="n">sim_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        V += (-V + Isyn) * (dt / tau);</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">threshold_condition_code</span><span class="o">=</span><span class="s2">&quot;V &gt;= 1.0&quot;</span><span class="p">,</span>
    <span class="n">reset_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        V = 0.0;</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>

    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">],</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">VarAccess</span><span class="o">.</span><span class="n">READ_WRITE</span><span class="p">)])</span>
</pre></div>
</div>
<section id="additional-input-variables">
<h4>Additional input variables<a class="headerlink" href="#additional-input-variables" title="Permalink to this heading"></a></h4>
<p>Normally, neuron models receive the linear sum of the inputs coming from all of their synaptic inputs through the <code class="docutils literal notranslate"><span class="pre">Isyn</span></code> variable.
However neuron models can define additional input variables, allowing input from different synaptic inputs to be combined non-linearly.
For example, if we wanted our leaky integrator to operate on the the product of two input currents, we could modify our model as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">additional_input_vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;Isyn2&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)],</span>
<span class="n">sim_code</span><span class="o">=</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    const scalar input = Isyn * Isyn2;</span>
<span class="sd">    sim_code=&quot;V += (-V + input) * (dt / tau);</span>
<span class="sd">    &quot;&quot;&quot;</span><span class="p">,</span>
<span class="o">...</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
<section id="weight-update-models">
<h3>Weight update models<a class="headerlink" href="#weight-update-models" title="Permalink to this heading"></a></h3>
<p>Weight update models define the event-driven and time-driven behaviour of synapses and what output they deliver to postsynaptic (and presynaptic) neurons.
New weight update models are defined by calling:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_weight_update_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_vars=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_</span> <span class="pre">post_vars=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_</span> <span class="pre">pre_neuron_var_refs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_neuron_var_refs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_spike_syn_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_event_syn_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_event_syn_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_spike_syn_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synapse_dynamics_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_</span> <span class="pre">post_</span> <span class="pre">pre_spike_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_spike_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_dynamics_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_dynamics_code=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params=None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new weight update model.
GeNN operates on the assumption that the postsynaptic output of the synapses are added linearly at the postsynaptic neuron.
Within all of the synaptic code strings (<code class="docutils literal notranslate"><span class="pre">pre_spike_syn_code</span></code>, <code class="docutils literal notranslate"><span class="pre">pre_event_syn_code</span></code>,
<code class="docutils literal notranslate"><span class="pre">post_event_syn_code</span></code>, <code class="docutils literal notranslate"><span class="pre">post_spike_syn_code</span></code> and <code class="docutils literal notranslate"><span class="pre">synapse_dynamics_code</span></code> ) these currents are delivered using the <code class="docutils literal notranslate"><span class="pre">addToPost(inc)</span></code> function.
For example,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pre_spike_syn_code</span><span class="o">=</span><span class="s2">&quot;addToPost(inc);&quot;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">inc</span></code> is the amount to add to the postsynapse model’s <code class="docutils literal notranslate"><span class="pre">inSyn</span></code> variable for each pre-synaptic spike.
Dendritic delays can also be inserted between the synapse and the postsynaptic neuron by using the <code class="docutils literal notranslate"><span class="pre">addToPostDelay(inc,</span> <span class="pre">delay)</span></code> function.
For example,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pre_spike_syn_code</span><span class="o">=</span><span class="s2">&quot;addToPostDelay(inc, delay);&quot;</span>
</pre></div>
</div>
<p>where, once again, <code class="docutils literal notranslate"><span class="pre">inc</span></code> is the amount to add to the postsynaptic neuron’s <code class="docutils literal notranslate"><span class="pre">inSyn</span></code> variable and <code class="docutils literal notranslate"><span class="pre">delay</span></code> is the length of the dendritic delay in timesteps.
By implementing <code class="docutils literal notranslate"><span class="pre">delay</span></code> as a weight update model variable, heterogeneous synaptic delays can be implemented.
For an example, see WeightUpdateModels::StaticPulseDendriticDelay for a simple synapse update model with heterogeneous dendritic delays.</p>
<p>When using dendritic delays, the <em>maximum</em> dendritic delay for a synapse populations must be specified via the
<a class="reference internal" href="source/pygenn.html#pygenn.SynapseGroup.max_dendritic_delay_timesteps" title="pygenn.SynapseGroup.max_dendritic_delay_timesteps"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseGroup.max_dendritic_delay_timesteps</span></code></a> property. One can also define synaptic effects that occur in the reverse direction,
i.e. terms that are added to a target variable in the _presynaptic_ neuron using the <code class="docutils literal notranslate"><span class="pre">addToPre(inc)</span></code> function. For example,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pre_spike_syn_code</span><span class="o">=</span><span class="s2">&quot;addToPre(inc * V_post);&quot;</span>
</pre></div>
</div>
<p>would add terms <code class="docutils literal notranslate"><span class="pre">inc</span> <span class="pre">*</span> <span class="pre">V_post</span></code> to for each <em>outgoing</em> synapse of a presynaptic neuron.
Similar to postsynaptic models, by default these inputs are accumulated in <code class="docutils literal notranslate"><span class="pre">Isyn</span></code> in the presynaptic
neuron but they can also be directed to additional input variables by setting the
<a class="reference internal" href="source/pygenn.html#pygenn.SynapseGroup.pre_target_var" title="pygenn.SynapseGroup.pre_target_var"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseGroup.pre_target_var</span></code></a> property. Unlike for normal forward synaptic
actions, reverse synaptic actions with <code class="docutils literal notranslate"><span class="pre">addToPre(inc)</span></code> are not modulated through
a post-synaptic model but added directly into the indicated presynaptic target input variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of per-synapse model variables</p></li>
<li><p><strong>pre_vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of per-presynaptic neuron model variables</p></li>
<li><p><strong>names</strong> (<em>post_vars</em>) – modifiers of per-postsynaptic neuron model variables</p></li>
<li><p><strong>access</strong> (<em>types and optional variable</em>) – modifiers of per-postsynaptic neuron model variables</p></li>
<li><p><strong>pre_neuron_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to presynaptic
neuron variables</p></li>
<li><p><strong>post_neuron_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to postsynaptic
neuron variables</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>pre_spike_syn_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the presynaptic spike code</p></li>
<li><p><strong>pre_event_syn_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the presynaptic event code</p></li>
<li><p><strong>post_event_syn_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the postsynaptic event code</p></li>
<li><p><strong>post_spike_syn_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the postsynaptic spike code</p></li>
<li><p><strong>synapse_dynamics_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the synapse dynamics code</p></li>
<li><p><strong>pre_event_threshold_condition_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the presynaptic event threshold
condition code</p></li>
<li><p><strong>post_event_threshold_condition_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the postsynaptic event threshold
condition code</p></li>
<li><p><strong>pre_spike_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the code run once per
spiking presynaptic neuron. Only
presynaptic variables and
variable references can be
referenced from this code.</p></li>
<li><p><strong>post_spike_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the code run once per
spiking postsynaptic neuron</p></li>
<li><p><strong>pre_dynamics_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the code run every
timestep on presynaptic neuron.
Only presynaptic variables and
variable references can be
referenced from this code.</p></li>
<li><p><strong>post_dynamics_code</strong> (<em>str</em><em> | </em><em>None</em>) – string with the code run every
timestep on postsynaptic neuron.
Only postsynaptic variables and
variable references can be
referenced from this code.</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of model
extra global parameters</p></li>
<li><p><strong>post_vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
</ul>
</dd>
</dl>
<p>For example, we can define a simple additive STDP rule with
nearest-neighbour spike pairing and the following time-dependence (equivalent to <a class="reference internal" href="source/pygenn.html#pygenn.weight_update_models.STDP" title="pygenn.weight_update_models.STDP"><code class="xref py py-func docutils literal notranslate"><span class="pre">weight_update_models.STDP()</span></code></a>):</p>
<div class="math notranslate nohighlight">
\[\begin{split}\Delta w_{ij} &amp; =             \begin{cases}
        A_{+}\exp\left(-\frac{\Delta t}{\tau_{+}}\right) &amp; if\, \Delta t&gt;0\\
        A_{-}\exp\left(\frac{\Delta t}{\tau_{-}}\right) &amp; if\, \Delta t\leq0
    \end{cases}\end{split}\]</div>
<p>in a fully event-driven manner as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">stdp_additive_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_weight_update_model</span><span class="p">(</span>
    <span class="s2">&quot;stdp_additive&quot;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;tauPlus&quot;</span><span class="p">,</span> <span class="s2">&quot;tauMinus&quot;</span><span class="p">,</span> <span class="s2">&quot;aPlus&quot;</span><span class="p">,</span> <span class="s2">&quot;aMinus&quot;</span><span class="p">,</span> <span class="s2">&quot;wMin&quot;</span><span class="p">,</span> <span class="s2">&quot;wMax&quot;</span><span class="p">],</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>

    <span class="n">pre_spike_syn_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        addToPost(g);</span>
<span class="sd">        const scalar dt = t - st_post;</span>
<span class="sd">        if (dt &gt; 0) {</span>
<span class="sd">            const scalar timing = exp(-dt / tauMinus);</span>
<span class="sd">            const scalar newWeight = g - (Aminus * timing);</span>
<span class="sd">            g = fmax(Wmin, fmin(Wmax, newWeight));</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">post_spike_syn_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        const scalar dt = t - st_pre;</span>
<span class="sd">        if (dt &gt; 0) {</span>
<span class="sd">            const scalar timing = exp(-dt / tauPlus);</span>
<span class="sd">            const scalar newWeight = g + (Aplus * timing);</span>
<span class="sd">            g = fmax(Wmin, fmin(Wmax, newWeight));</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<section id="pre-and-postsynaptic-dynamics">
<h4>Pre and postsynaptic dynamics<a class="headerlink" href="#pre-and-postsynaptic-dynamics" title="Permalink to this heading"></a></h4>
<p>The memory required for synapse variables and the computational cost of updating them tends to grow with <span class="math notranslate nohighlight">\(O(N^2)\)</span> with the number of neurons.
Therefore, if it is possible, implementing synapse variables on a per-neuron rather than per-synapse basis is a good idea.
The <code class="docutils literal notranslate"><span class="pre">pre_var_name_types</span></code> and <code class="docutils literal notranslate"><span class="pre">post_var_name_types</span></code> keyword arguments are used to define any pre or postsynaptic state variables.
For example, using pre and postsynaptic variables, our event-driven STDP rule can be extended to use all-to-all spike pairing using pre and postsynaptic <em>trace</em> variables <a class="reference internal" href="bibliography.html#morrison2008" id="id3"><span>[Morrison2008]</span></a> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">stdp_additive_2_model</span> <span class="o">=</span> <span class="n">genn_model</span><span class="o">.</span><span class="n">create_custom_weight_update_class</span><span class="p">(</span>
    <span class="s2">&quot;stdp_additive_2&quot;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;tauPlus&quot;</span><span class="p">,</span> <span class="s2">&quot;tauMinus&quot;</span><span class="p">,</span> <span class="s2">&quot;aPlus&quot;</span><span class="p">,</span> <span class="s2">&quot;aMinus&quot;</span><span class="p">,</span> <span class="s2">&quot;wMin&quot;</span><span class="p">,</span> <span class="s2">&quot;wMax&quot;</span><span class="p">],</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>
    <span class="n">pre_vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;preTrace&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>
    <span class="n">post_vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;postTrace&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>

    <span class="n">pre_spike_syn_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        addToPost(g);</span>
<span class="sd">        const scalar dt = t - st_post;</span>
<span class="sd">        if(dt &gt; 0) {</span>
<span class="sd">            const scalar newWeight = g - (aMinus * postTrace);</span>
<span class="sd">            g = fmin(wMax, fmax(wMin, newWeight));</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">post_spike_syn_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        const scalar dt = t - st_pre;</span>
<span class="sd">        if(dt &gt; 0) {</span>
<span class="sd">            const scalar newWeight = g + (aPlus * preTrace);</span>
<span class="sd">            g = fmin(wMax, fmax(wMin, newWeight));</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>

    <span class="n">pre_spike_code</span><span class="o">=</span><span class="s2">&quot;preTrace += 1.0;&quot;</span><span class="p">,</span>
    <span class="n">pre_dynamics_code</span><span class="o">=</span><span class="s2">&quot;preTrace *= tauPlusDecay;&quot;</span><span class="p">,</span>
    <span class="n">post_spike_code</span><span class="o">=</span><span class="s2">&quot;postTrace += 1.0;&quot;</span><span class="p">,</span>
    <span class="n">post_dynamics_code</span><span class="o">=</span><span class="s2">&quot;postTrace *= tauMinusDecay;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<section id="synapse-dynamics">
<h5>Synapse dynamics<a class="headerlink" href="#synapse-dynamics" title="Permalink to this heading"></a></h5>
<p>Unlike the event-driven updates previously described, synapse dynamics code is run for each synapse and each timestep, i.e. it is time-driven.
This can be used where synapses have internal variables and dynamics that are described in continuous time, e.g. by ODEs.
However, using this mechanism is typically computationally very costly because of the large number of synapses in a typical network.
By using the <code class="docutils literal notranslate"><span class="pre">addToPost()</span></code> and <code class="docutils literal notranslate"><span class="pre">addToPostDelay()</span></code> functions discussed in the context of <code class="docutils literal notranslate"><span class="pre">pre_spike_syn_code</span></code>, the synapse dynamics can also be used to implement continuous synapses for rate-based models.
For example a continous synapse which multiplies a presynaptic neuron variable by the weight could be added to a weight update model definition as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pre_neuron_var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;V_pre&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>
<span class="n">synapse_dynamics_code</span><span class="o">=</span><span class="s2">&quot;addToPost(g * V_pre);&quot;</span><span class="p">,</span>
</pre></div>
</div>
</section>
<section id="spike-like-events">
<h5>Spike-like events<a class="headerlink" href="#spike-like-events" title="Permalink to this heading"></a></h5>
<p>As well as time-driven synapse dynamics and spike event-driven updates, GeNN weight update models also support “spike-like events”.
These can be triggered by a threshold condition evaluated on the pre or postsynaptic neuron.
This typically involves pre or postsynaptic weight update model variables or variable references respectively.</p>
<p>For example, to trigger a presynaptic spike-like event when the presynaptic neuron’s voltage is greater than 0.02, the following could be added to a weight update model definition:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pre_neuron_var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;V_pre&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>
<span class="n">pre_event_threshold_condition_code</span><span class="o">=</span><span class="s2">&quot;V_pre &gt; -0.02&quot;</span>
</pre></div>
</div>
<p>Whenever this expression evaluates to true, the event code in <code class="docutils literal notranslate"><span class="pre">pre_event_code</span></code> will be executed.</p>
</section>
</section>
</dd></dl>

</section>
<section id="postsynaptic-models">
<h3>Postsynaptic models<a class="headerlink" href="#postsynaptic-models" title="Permalink to this heading"></a></h3>
<p>The postsynaptic model defines how synaptic input translates into an input current (or other input term for models that are not current based).
They can contain equations defining dynamics that are applied to the (summed) synaptic activation, e.g. an exponential decay over time.
New postsynaptic models are defined by calling:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_postsynaptic_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neuron_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new postsynaptic update model.
Within all of the code strings, the variables, parameters,
derived parameters and extra global parameters defined in this model
can all be referred to by name. Additionally, the code may refer to the
following built-in read-only variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code> which represents a neurons index within a population (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_neurons</span></code> which represents the number of neurons in the population</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inSyn</span></code> which contains the summed input received from the weight update model through <code class="docutils literal notranslate"><span class="pre">addToPost()</span></code> or <code class="docutils literal notranslate"><span class="pre">addToPostDelay()</span></code></p></li>
</ul>
<p>Finally, the function <code class="docutils literal notranslate"><span class="pre">injectCurrent(x)</span></code> can be used to inject a current
<code class="docutils literal notranslate"><span class="pre">x</span></code> into the postsynaptic neuron. The variable it goes into can be
configured using the <a class="reference internal" href="source/pygenn.html#pygenn.SynapseGroup.post_target_var" title="pygenn.SynapseGroup.post_target_var"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseGroup.post_target_var</span></code></a>. By default it targets <code class="docutils literal notranslate"><span class="pre">Isyn</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> – names, types and optional variable access
modifiers of model variables</p></li>
<li><p><strong>neuron_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to postsynaptic
neuron variables</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>sim_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the simulation code
statements to be run every timestep</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of model
extra global parameters</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="current-source-models">
<h3>Current source models<a class="headerlink" href="#current-source-models" title="Permalink to this heading"></a></h3>
<p>Current source models allow input currents to be injected into neuron models.
New current source models are defined by calling:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_current_source_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neuron_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">injection_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new current source model.
Within the <code class="docutils literal notranslate"><span class="pre">injection_code</span></code> code string, the variables, parameters,
derived parameters, neuron variable references and extra global
parameters defined in this model can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code> which represents a neurons index within a population (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_neurons</span></code> which represents the number of neurons in the population</p></li>
</ul>
<p>Finally, the function <code class="docutils literal notranslate"><span class="pre">injectCurrent(x)</span></code> can be used to inject a current
<code class="docutils literal notranslate"><span class="pre">x</span></code> into the attached neuron. The variable it goes into can be
configured using the <code class="xref py py-attr docutils literal notranslate"><span class="pre">CurrentSource.target_var</span></code>. It defaults to <code class="docutils literal notranslate"><span class="pre">Isyn</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of model variables</p></li>
<li><p><strong>neuron_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to variables
in neuron population current source is attached to</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>injection_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the simulation code
statements to be run every timestep</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of model
extra global parameters</p></li>
</ul>
</dd>
</dl>
<p>For example, we can define a simple current source that
injects uniformly-distributed noise as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">uniform_noise_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_current_source_model</span><span class="p">(</span>
    <span class="s2">&quot;uniform_noise&quot;</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;magnitude&quot;</span><span class="p">],</span>
    <span class="n">injection_code</span><span class="o">=</span><span class="s2">&quot;injectCurrent(gennrand_uniform() * magnitude);&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="custom-update-models">
<h3>Custom update models<a class="headerlink" href="#custom-update-models" title="Permalink to this heading"></a></h3>
<p>Custom update models define operations on model variables that can be triggered on demand by the user.
New custom update models are defined by calling:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_custom_update_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_param_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new custom update model.
Within the <code class="docutils literal notranslate"><span class="pre">update_code</span></code> code string, the variables, parameters,
derived parameters, variable references, extra global parameters
and extra global parameter references defined in this model can all be referred to by name.
Additionally, the code may refer to the following built-in read-only variables</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
</ul>
<blockquote>
<div><p>And, if a custom update using this model is attached to per-neuron variables:</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code> which represents a neurons index within a population (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_neurons</span></code> which represents the number of neurons in the population</p></li>
</ul>
<p>or, to per-synapse variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id_pre</span></code> which represents the index of the presynaptic neuron (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id_post</span></code> which represents the index of the postsynaptic neuron (starting from zero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pre</span></code> which represents the number of presynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_post</span></code> which represents the number of postsynaptic neurons</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.CustomUpdateVarAccess" title="pygenn._genn.CustomUpdateVarAccess"><em>CustomUpdateVarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of model variables</p></li>
<li><p><strong>var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to variables
in population(s) custom update is attached to</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>update_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the code statements
to be run when custom update is launched</p></li>
<li><p><strong>extra_global_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names and types of model
extra global parameters</p></li>
<li><p><strong>extra_global_param_refs</strong> – names and types of extra global
parameter references</p></li>
</ul>
</dd>
</dl>
<p>For example, we can define a custom update which will set a referenced variable to the value of a custom update model state variable:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">reset_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_update_model</span><span class="p">(</span>
    <span class="s2">&quot;reset&quot;</span><span class="p">,</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">CustomUpdateVarAccess</span><span class="o">.</span><span class="n">READ_ONLY</span><span class="p">)],</span>
    <span class="n">var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">VarAccessMode</span><span class="o">.</span><span class="n">READ_WRITE</span><span class="p">)],</span>
    <span class="n">update_code</span><span class="o">=</span><span class="s2">&quot;r = v;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>When used in a model with batch size &gt; 1, whether custom updates of this sort are batched or not depends on the variables their references point to.
If any referenced variables have <a class="reference internal" href="source/pygenn.html#pygenn.VarAccess.READ_ONLY_DUPLICATE" title="pygenn.VarAccess.READ_ONLY_DUPLICATE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccess.READ_ONLY_DUPLICATE</span></code></a> or <a class="reference internal" href="source/pygenn.html#pygenn.VarAccess.READ_WRITE" title="pygenn.VarAccess.READ_WRITE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccess.READ_WRITE</span></code></a> access modes, then the update will be batched
and any variables associated with the custom update with <a class="reference internal" href="source/pygenn.html#pygenn.VarAccess.READ_ONLY_DUPLICATE" title="pygenn.VarAccess.READ_ONLY_DUPLICATE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccess.READ_ONLY_DUPLICATE</span></code></a> or <a class="reference internal" href="source/pygenn.html#pygenn.VarAccess.READ_WRITE" title="pygenn.VarAccess.READ_WRITE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccess.READ_WRITE</span></code></a> access modes will be duplicated across the batches.</p>
<section id="batch-reduction">
<h4>Batch reduction<a class="headerlink" href="#batch-reduction" title="Permalink to this heading"></a></h4>
<p>As well as the standard variable access modes described previously, custom updates support variables with ‘batch reduction’ access modes
such as <a class="reference internal" href="source/pygenn.html#pygenn.CustomUpdateVarAccess.REDUCE_BATCH_SUM" title="pygenn.CustomUpdateVarAccess.REDUCE_BATCH_SUM"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CustomUpdateVarAccess.REDUCE_BATCH_SUM</span></code></a> and <a class="reference internal" href="source/pygenn.html#pygenn.CustomUpdateVarAccess.REDUCE_BATCH_MAX" title="pygenn.CustomUpdateVarAccess.REDUCE_BATCH_MAX"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CustomUpdateVarAccess.REDUCE_BATCH_MAX</span></code></a>.
These access modes allow values read from variables duplicated across batches to be reduced into variables that are shared across batches.
For example, in a gradient-based learning scenario, a model like this could be used to sum gradients from across all batches so they can be used as the input to a learning rule operating on shared synaptic weights:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">reduce_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_update_model</span><span class="p">(</span>
    <span class="s2">&quot;gradient_batch_reduce&quot;</span><span class="p">,</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;reducedGradient&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">CustomUpdateVarAccess</span><span class="o">.</span><span class="n">REDUCE_BATCH_SUM</span><span class="p">)],</span>
    <span class="n">var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">VarAccessMode</span><span class="o">.</span><span class="n">READ_ONLY</span><span class="p">)],</span>
    <span class="n">update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reducedGradient = gradient;</span>
<span class="sd">        gradient = 0;</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Batch reductions can also be performed into variable references with
the <a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode.REDUCE_SUM" title="pygenn.VarAccessMode.REDUCE_SUM"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccessMode.REDUCE_SUM</span></code></a> or <a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode.REDUCE_MAX" title="pygenn.VarAccessMode.REDUCE_MAX"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccessMode.REDUCE_MAX</span></code></a> access modes.</p>
</section>
<section id="neuron-reduction">
<h4>Neuron reduction<a class="headerlink" href="#neuron-reduction" title="Permalink to this heading"></a></h4>
<p>Similarly to the batch reduction modes discussed previously, custom updates also support variables with several ‘neuron reduction’ access modes
such as <a class="reference internal" href="source/pygenn.html#pygenn.CustomUpdateVarAccess.REDUCE_NEURON_SUM" title="pygenn.CustomUpdateVarAccess.REDUCE_NEURON_SUM"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CustomUpdateVarAccess.REDUCE_NEURON_SUM</span></code></a> and <a class="reference internal" href="source/pygenn.html#pygenn.CustomUpdateVarAccess.REDUCE_NEURON_MAX" title="pygenn.CustomUpdateVarAccess.REDUCE_NEURON_MAX"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CustomUpdateVarAccess.REDUCE_NEURON_MAX</span></code></a>.</p>
<p>These access modes allow values read from per-neuron variables to be reduced into variables that are shared across neurons.
For example, a model like this could be used to calculate the maximum value of a state variable in a population of neurons:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">reduce_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_update_model</span><span class="p">(</span>
    <span class="s2">&quot;neuron_reduce&quot;</span><span class="p">,</span>
    <span class="nb">vars</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;reduction&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">CustomUpdateVarAccess</span><span class="o">.</span><span class="n">REDUCE_NEURON_SUM</span><span class="p">)],</span>
    <span class="n">var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">VarAccessMode</span><span class="o">.</span><span class="n">READ_ONLY</span><span class="p">)],</span>
    <span class="n">update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reduction = source;</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, like batch reductions, neuron reductions can also be performed into variable references with
the <a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode.REDUCE_SUM" title="pygenn.VarAccessMode.REDUCE_SUM"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccessMode.REDUCE_SUM</span></code></a> or <a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode.REDUCE_MAX" title="pygenn.VarAccessMode.REDUCE_MAX"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VarAccessMode.REDUCE_MAX</span></code></a> access modes.</p>
</section>
</dd></dl>

</section>
<section id="custom-connectivity-update-models">
<h3>Custom connectivity update models<a class="headerlink" href="#custom-connectivity-update-models" title="Permalink to this heading"></a></h3>
<p>Custom update models define operations on model connectivity that can be triggered on demand by the user.
New custom connectivity update models are defined by calling:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pygenn.</span></span><span class="sig-name descname"><span class="pre">create_custom_connectivity_update_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_vars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">post_var_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_update_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host_update_code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_global_param_refs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a new custom connectivity update model.</p>
<p>Within host update code, you have full access to parameters, derived parameters,
extra global parameters and pre and postsynaptic variables. By design you do
not have access to per-synapse variables or variable references and, currently,
you cannot access pre and postsynaptic variable references as there are issues regarding delays.
Each variable has an accompanying push and pull function to copy it to and from the device.
For variables these have no parameters as illustrated in the example in <a class="reference internal" href="simulating_networks.html#section-pull-push"><span class="std std-ref">Pushing and pulling</span></a>, and for
extra global parameters they have a single parameter specifying the size of the array.
Within the row update code you have full access to parameters, derived parameters,
extra global parameters, presynaptic variables and presynaptic variables references.
Postsynaptic and synaptic variables and variables references can only be accessed
from within one of the <code class="docutils literal notranslate"><span class="pre">for_each_synapse</span></code> loops illustrated below.
Additionally, both the host and row update code cam refer to the following built-in
read-only variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dt</span></code> which represents the simulation time step (as specified via  <code class="xref py py-meth docutils literal notranslate"><span class="pre">GeNNModel.dt()</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">row_stride</span></code> which represents the maximum number of synapses which each presynaptic neuron can have (this can be increased via <a class="reference internal" href="source/pygenn.html#pygenn.SynapseGroup.max_connections" title="pygenn.SynapseGroup.max_connections"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SynapseGroup.max_connections</span></code></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_pre</span></code> which represents the number of presynaptic neurons</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_post</span></code> which represents the number of postsynaptic neurons</p></li>
</ul>
<p>Host code can also access the current number of synapses emanating from each presynaptic
neuron using the <code class="docutils literal notranslate"><span class="pre">row_length</span></code> array whereas, in row-update code, this contains the number of
synapses emanating from the current presynaptic neuron (identified by <code class="docutils literal notranslate"><span class="pre">id_pre</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_name</strong> (<em>str</em>) – name of the new class (only for debugging)</p></li>
<li><p><strong>params</strong> (<em>Sequence</em><em>[</em><em>str</em><em> | </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – name and optional types of model parameters</p></li>
<li><p><strong>vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of per-synapse model variables</p></li>
<li><p><strong>pre_vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
modifiers of per-presynaptic neuron model variables</p></li>
<li><p><strong>names</strong> (<em>post_vars</em>) – modifiers of per-postsynaptic neuron model variables</p></li>
<li><p><strong>access</strong> (<em>types and optional variable</em>) – modifiers of per-postsynaptic neuron model variables</p></li>
<li><p><strong>derived_params</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>Callable</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and callables to calculate
derived parameter values from params</p></li>
<li><p><strong>var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – names, types and optional variable access
of references to be assigned to synaptic variables</p></li>
<li><p><strong>pre_neuron_var_refs</strong> – names, types and optional variable access
of references to be assigned to presynaptic
neuron variables</p></li>
<li><p><strong>post_neuron_var_refs</strong> – names, types and optional variable access
of references to be assigned to postsynaptic
neuron variables</p></li>
<li><p><strong>row_update_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the code statements
to be run when custom update is launched</p></li>
<li><p><strong>host_update_code</strong> (<em>str</em><em> | </em><em>None</em>) – string containing the code statements to be run
on CPU when custom connectivity update is launched</p></li>
<li><p><strong>extra_global_params</strong> – names and types of model
extra global parameters</p></li>
<li><p><strong>extra_global_param_refs</strong> – names and types of extra global
parameter references</p></li>
<li><p><strong>post_vars</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccess" title="pygenn._genn.VarAccess"><em>VarAccess</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
<li><p><strong>pre_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
<li><p><strong>post_var_refs</strong> (<em>Sequence</em><em>[</em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>] </em><em>| </em><em>Tuple</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>ResolvedType</em><em>, </em><a class="reference internal" href="source/pygenn.html#pygenn.VarAccessMode" title="pygenn._genn.VarAccessMode"><em>VarAccessMode</em></a><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
</ul>
</dd>
</dl>
<section id="parallel-synapse-iteration-and-removal">
<h4>Parallel synapse iteration and removal<a class="headerlink" href="#parallel-synapse-iteration-and-removal" title="Permalink to this heading"></a></h4>
<p>The main GPU operation that custom connectivity updates expose is the ability to generate per-presynaptic neuron update code. This can be used to implement a very simple model which removes ‘diagonals’ from the connectivity matrix:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">remove_diagonal_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_connectivity_update_model</span><span class="p">(</span>
    <span class="s2">&quot;remove_diagonal&quot;</span><span class="p">,</span>
    <span class="n">row_update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for_each_synapse {</span>
<span class="sd">            if(id_post == id_pre) {</span>
<span class="sd">                remove_synapse();</span>
<span class="sd">                break;</span>
<span class="sd">            }</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="parallel-synapse-creation">
<h4>Parallel synapse creation<a class="headerlink" href="#parallel-synapse-creation" title="Permalink to this heading"></a></h4>
<p>Similarly you could implement a custom connectivity model which adds diagonals back into the connection matrix like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">add_diagonal_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_connectivity_update_model</span><span class="p">(</span>
    <span class="s2">&quot;add_diagonal&quot;</span><span class="p">,</span>
    <span class="n">row_update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add_synapse(id_pre);</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>One important issue here is that lots of other parts of the model (e.g. other custom connectivity updates or custom weight updates) <em>might</em> have state variables ‘attached’ to the same connectivity that the custom update is modifying. GeNN will automatically detect this and add and shuffle all these variables around accordingly which is fine for removing synapses but has no way of knowing what value to add synapses with. If you want new synapses to be created with state variables initialised to values other than zero, you need to use variables references to hook them to the custom connectivity update. For example, if you wanted to be able to provide weights for your new synapse, you could update the previous example model like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">add_diagonal_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_connectivity_update_model</span><span class="p">(</span>
    <span class="s2">&quot;add_diagonal&quot;</span><span class="p">,</span>
    <span class="n">var_refs</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;scalar&quot;</span><span class="p">)],</span>
    <span class="n">row_update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add_synapse(id_pre, 1.0);</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="host-updates">
<h4>Host updates<a class="headerlink" href="#host-updates" title="Permalink to this heading"></a></h4>
<p>Some common connectivity update scenarios involve some computation which can’t be easily parallelized. If, for example you wanted to determine which elements on each row you wanted to remove on the host, you can include <code class="docutils literal notranslate"><span class="pre">host_update_code</span></code> which gets run before the row update code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">remove_diagonal_model</span> <span class="o">=</span> <span class="n">pygenn</span><span class="o">.</span><span class="n">create_custom_connectivity_update_model</span><span class="p">(</span>
    <span class="s2">&quot;remove_diagonal&quot;</span><span class="p">,</span>
    <span class="n">pre_var_name_types</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;postInd&quot;</span><span class="p">,</span> <span class="s2">&quot;unsigned int&quot;</span><span class="p">)],</span>
    <span class="n">row_update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for_each_synapse {</span>
<span class="sd">            if(id_post == postInd) {</span>
<span class="sd">                remove_synapse();</span>
<span class="sd">                break;</span>
<span class="sd">            }</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">host_update_code</span><span class="o">=</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for(unsigned int i = 0; i &lt; num_pre; i++) {</span>
<span class="sd">           postInd[i] = i;</span>
<span class="sd">        }</span>
<span class="sd">        pushpostIndToDevice();</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="simulating_networks.html" class="btn btn-neutral float-left" title="Simulating networks" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="bibliography.html" class="btn btn-neutral float-right" title="Bibliography" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, James Knight, Thomas Nowotny.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>