<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>GeNN: Best practices guide</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../multi-language-utils.js"></script>
<!--This is Google Analytics Tracking Code-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-57354659-1', 'auto');
  ga('send', 'pageview');
</script>
<!--End of Google Analytics Tracking Code-->
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css" />
<link href="../../html_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em; padding-bottom: 0.5em;" id="projectlogo"><img alt="Logo" src="../../GeNN-logo-55px.gif"/></td>
  <td style="padding-left: 3.5em; padding-bottom: 0.5em;">
   <div id="projectname">GeNN
   &#160;<span id="projectnumber">4.4.0</span>
   </div>
   <div id="projectbrief">GPU enhanced Neuronal Networks (GeNN)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d0/da6/UserGuide.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Best practices guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>GeNN generates code according to the network model defined by the user as described in <a class="el" href="../../dc/d05/UserManual.html">User Manual</a> <span class='toggleable_div label_cpp' style='display: none;'>, and allows users to include the generated code in their programs as they want </span>. Here we provide a guideline to setup GeNN and use generated functions. We recommend users to also <span class='toggleable_div label_cpp' style='display: none;'>have a look at the <a class="el" href="../../d9/d61/Examples.html">Examples</a>, and to follow the tutorials <a class="el" href="../../d5/dbb/Tutorial1.html">Tutorial 1 (C++)</a> and <a class="el" href="../../dc/d7e/Tutorial2.html">Tutorial 2 (C++)</a></span><span class='toggleable_div label_python' style='display: none;'>follow the tutorials <a class="el" href="../../d6/d8b/Tutorial1_Python.html">Tutorial 1 (Python)</a> and <a class="el" href="../../df/d0b/Tutorial2_Python.html">Tutorial 2 (Python)</a></span>.</p>
<h1><a class="anchor" id="Simulate"></a>
Simulating a network model</h1>
<p> <div class='toggleable_div label_cpp' style='display: none;'> Any variables marked as uninitialised using the <code><a class="el" href="../../dc/de1/modelSpec_8h.html#a6bd7d3c3ead0a4d0ffb15d2a4c67d043" title="Mark a variable as uninitialised. ">uninitialisedVar()</a></code> function or sparse connectivity not initialised using a snippet must be initialised by the user between calls to <code>initialize()</code> and <code>initializeSparse()</code>.</p>
<p>Core functions generated by GeNN to be included in the user code include:</p>
<ul>
<li><code>allocateMem()</code></li>
<li><code>initialize()</code></li>
<li><code>initializeSparse()</code></li>
<li><code>stepTime()</code></li>
<li><code>freeMem()</code></li>
<li><code>getFreeDeviceMemBytes()</code></li>
</ul>
<p>In order to correctly access neuron state and spikes for the current timestep, correctly accounting for delay buffering etc, you can use the <code>getCurrent&lt;var name&gt;&lt;neuron name&gt;()</code>, <code>get&lt;neuron name&gt;CurrentSpikes()</code> and <code>get&lt;neuron name&gt;CurrentSpikeCount()</code> functions.  </div>  <div class='toggleable_div label_python' style='display: none;'> The <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a481795d2e7a45410799786a1c5122834" title="Finalize and build a GeNN model. ">pygenn.genn_model.GeNNModel.build</a> method can then be used to generate code for your model. Subsequently, the model can be loaded using <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a662cf82b5390a03b117581a47b0ae147" title="import the model as shared library and initialize it ">pygenn.genn_model.GeNNModel.load</a> and simulated with <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a6d71c8d91805b64c5a69fc62ea3dfbdb">pygenn.genn_model.GeNNModel.step_time</a>. After calling <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a662cf82b5390a03b117581a47b0ae147" title="import the model as shared library and initialize it ">pygenn.genn_model.GeNNModel.load</a>, the <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a047deef538bec408e8e4086ece108ab8">pygenn.genn_model.GeNNModel.free_device_mem_bytes</a> property can be used on supported hardware-accelerated backends to determine how much free device memory remains.  </div></p>
<p>By setting <span class='toggleable_div label_cpp' style='display: none;'><code>GENN_PREFERENCES::automaticCopy</code> </span><span class='toggleable_div label_python' style='display: none;'> the <code>automaticCopy</code> keyword to <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a707a6343ef7de18dec66b562d3ab19af" title="Init GeNNModel. ">pygenn.genn_model.GeNNModel.__init__</a> </span>, GeNN can be used in a simple mode where CUDA automatically transfers data between the GPU and CPU when required (see <a href="https://devblogs.nvidia.com/unified-memory-cuda-beginners/">https://devblogs.nvidia.com/unified-memory-cuda-beginners/</a>). However, copying elements between the GPU and the host memory is costly in terms of performance and the automatic copying operates on a fairly coarse grain (pages are approximately 4 bytes). Therefore, in order to maximise performance, we recommend you do not use automatic copying and instead manually call the following <span class='toggleable_div label_cpp' style='display: none;'>functions</span><span class='toggleable_div label_python' style='display: none;'>methods</span> when required:  <div class='toggleable_div label_cpp' style='display: none;'></p><ul>
<li><code>push&lt;neuron or synapse name&gt;StateToDevice()</code></li>
<li><code>pull&lt;neuron or synapse name&gt;StateFromDevice()</code></li>
<li><code>push&lt;neuron name&gt;SpikesToDevice()</code></li>
<li><code>pull&lt;neuron name&gt;SpikesFromDevice()</code></li>
<li><code>push&lt;neuron name&gt;SpikesEventsToDevice()</code></li>
<li><code>pull&lt;neuron name&gt;SpikesEventsFromDevice()</code></li>
<li><code>push&lt;neuron name&gt;SpikeTimesToDevice()</code></li>
<li><code>pull&lt;neuron name&gt;SpikeTimesFromDevice()</code></li>
<li><code>push&lt;neuron name&gt;CurrentSpikesToDevice()</code></li>
<li><code>pull&lt;neuron name&gt;CurrentSpikesFromDevice()</code></li>
<li><code>push&lt;neuron name&gt;CurrentSpikeEventsToDevice()</code></li>
<li><code>pull&lt;neuron name&gt;CurrentSpikeEventsFromDevice()</code></li>
<li><code>pull&lt;synapse name&gt;ConnectivityFromDevice()</code></li>
<li><code>push&lt;synapse name&gt;ConnectivityToDevice()</code></li>
<li><code>pull&lt;var name&gt;&lt;neuron or synapse name&gt;FromDevice()</code></li>
<li><code>push&lt;var name&gt;&lt;neuron or synapse name&gt;ToDevice()</code></li>
<li><code>pushCurrent&lt;var name&gt;&lt;neuron name&gt;ToDevice()</code></li>
<li><code>pullCurrent&lt;var name&gt;&lt;neuron name&gt;FromDevice()</code></li>
<li><code>getCurrent&lt;var name&gt;&lt;neuron name&gt;()</code></li>
<li><code>copyStateToDevice()</code></li>
<li><code>copyStateFromDevice()</code></li>
<li><code>copyCurrentSpikesFromDevice()</code></li>
<li><code>copyCurrentSpikesEventsFromDevice()</code></li>
</ul>
<p> </div>  <div class='toggleable_div label_python' style='display: none;'></p><ul>
<li><a class="el" href="../../d1/db3/classpygenn_1_1genn__groups_1_1Group.html#ab075765fe8c89bd2f1285a0beccf8675" title="Wrapper around GeNNModel.pull_state_from_device. ">pygenn.genn_groups.Group.pull_state_from_device</a></li>
<li><a class="el" href="../../d1/db3/classpygenn_1_1genn__groups_1_1Group.html#abcec12cb1265ccbf88598a3d6865fafd" title="Wrapper around GeNNModel.pull_var_from_device. ">pygenn.genn_groups.Group.pull_var_from_device</a></li>
<li><a class="el" href="../../d1/db3/classpygenn_1_1genn__groups_1_1Group.html#ae8c81a75ebe5bac55dc9334226f7864d" title="Wrapper around GeNNModel.push_state_to_device. ">pygenn.genn_groups.Group.push_state_to_device</a></li>
<li><a class="el" href="../../d1/db3/classpygenn_1_1genn__groups_1_1Group.html#a70d941612e5dc677054034c781a544da" title="Wrapper around GeNNModel.push_var_to_device. ">pygenn.genn_groups.Group.push_var_to_device</a></li>
<li><a class="el" href="../../dc/dc9/classpygenn_1_1genn__groups_1_1NeuronGroup.html#a663d93bc0412391b5b349ce1ddb7495e" title="Wrapper around GeNNModel.pull_spikes_from_device. ">pygenn.genn_groups.NeuronGroup.pull_spikes_from_device</a></li>
<li><a class="el" href="../../dc/dc9/classpygenn_1_1genn__groups_1_1NeuronGroup.html#a32debd8385a75f67cbf220a02eb39abb" title="Wrapper around GeNNModel.pull_current_spikes_from_device. ">pygenn.genn_groups.NeuronGroup.pull_current_spikes_from_device</a></li>
<li><a class="el" href="../../dc/dc9/classpygenn_1_1genn__groups_1_1NeuronGroup.html#a69ff22a73e811a1fbe0b0791a64ec0ac" title="Wrapper around GeNNModel.push_spikes_to_device. ">pygenn.genn_groups.NeuronGroup.push_spikes_to_device</a></li>
<li><a class="el" href="../../dc/dc9/classpygenn_1_1genn__groups_1_1NeuronGroup.html#a7c19b0ba4b4ed6f33b44fa252a9007e4" title="Wrapper around GeNNModel.push_current_spikes_to_device. ">pygenn.genn_groups.NeuronGroup.push_current_spikes_to_device</a></li>
<li><a class="el" href="../../d5/d49/classpygenn_1_1genn__groups_1_1SynapseGroup.html#a726e27ca3ff43e9faec20d57fb7d8495" title="Wrapper around GeNNModel.pull_connectivity_from_device. ">pygenn.genn_groups.SynapseGroup.pull_connectivity_from_device</a></li>
<li><a class="el" href="../../d5/d49/classpygenn_1_1genn__groups_1_1SynapseGroup.html#a4da6b5ca742c0301fa9ab3f4c817f302" title="Wrapper around GeNNModel.push_connectivity_to_device. ">pygenn.genn_groups.SynapseGroup.push_connectivity_to_device</a></li>
</ul>
<p> </div> You can use <span class='toggleable_div label_cpp' style='display: none;'><code>push&lt;neuron or synapse name&gt;StateToDevice()</code> </span><span class='toggleable_div label_python' style='display: none;'><a class="el" href="../../d1/db3/classpygenn_1_1genn__groups_1_1Group.html#ae8c81a75ebe5bac55dc9334226f7864d" title="Wrapper around GeNNModel.push_state_to_device. ">pygenn.genn_groups.Group.push_state_to_device</a></span> to copy from the host to the GPU. At the end of your simulation, if you want to access the variables you need to copy them back from the device using the <span class='toggleable_div label_cpp' style='display: none;'><code>pull&lt;neuron or synapse name&gt;StateFromDevice()</code> function </span><span class='toggleable_div label_python' style='display: none;'> <a class="el" href="../../d1/db3/classpygenn_1_1genn__groups_1_1Group.html#ab075765fe8c89bd2f1285a0beccf8675" title="Wrapper around GeNNModel.pull_state_from_device. ">pygenn.genn_groups.Group.pull_state_from_device</a> method </span> or one of the more fine-grained functions listed above.</p>
<h2><a class="anchor" id="extraGlobalParamSim"></a>
Extra Global Parameters</h2>
<p>If extra global parameters have a "scalar" type such as <code>float</code> they can be set directly from simulation code. For example the extra global parameter "reward" of <span class='toggleable_div label_cpp' style='display: none;'>population "Pop" can be set with</span><span class='toggleable_div label_python' style='display: none;'><a class="el" href="../../dc/dc9/classpygenn_1_1genn__groups_1_1NeuronGroup.html" title="Class representing a group of neurons. ">pygenn.genn_groups.NeuronGroup</a> "pop" should first be initialised before <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a662cf82b5390a03b117581a47b0ae147" title="import the model as shared library and initialize it ">pygenn.genn_model.GeNNModel.load</a> is called with</span>:  <div class='toggleable_div label_cpp' style='display: none;'></p><div class="fragment"><div class="line">rewardPop = 5.0f;</div></div><!-- fragment --><p> </div>  <div class='toggleable_div label_python' style='display: none;'></p><div class="fragment"><div class="line">pop.set_extra_global_param(<span class="stringliteral">&quot;reward&quot;</span>, 5.0)</div></div><!-- fragment --><p> </div>  <div class='toggleable_div label_python' style='display: none;'> and subsequently can be updated with: </p><div class="fragment"><div class="line">pop.extra_global_params[<span class="stringliteral">&quot;reward&quot;</span>].view[:] = 5.0</div></div><!-- fragment --><p>  </div>  <div class='toggleable_div label_cpp' style='display: none;'> However, if extra global parameters have a pointer type such as <code>float*</code>, GeNN generates additional functions to allocate, free and copy these extra global parameters between host and device:</p><ul>
<li><code>allocate&lt;egp name&gt;&lt;neuron or synapse name&gt;</code></li>
<li><code>free&lt;egp name&gt;&lt;neuron or synapse name&gt;</code></li>
<li><code>push&lt;egp name&gt;&lt;neuron or synapse name&gt;ToDevice</code></li>
<li><code>pull&lt;egp name&gt;&lt;neuron or synapse name&gt;FromDevice</code> These operate in much the same manner as the functions for interacting with standard variables described above but the allocate, push and pull functions all take a "count" parameter specifying how many entries the extra global parameter array should be.  </div>  <div class='toggleable_div label_python' style='display: none;'> Extra global parameters with a pointer type such as <code>float*</code> should be initialised and updated in the same manner but, if their value is changed after <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a662cf82b5390a03b117581a47b0ae147" title="import the model as shared library and initialize it ">pygenn.genn_model.GeNNModel.load</a> is called, the updated values need to be pushed to the GPU: <div class="fragment"><div class="line">pop.extra_global_params[<span class="stringliteral">&quot;reward&quot;</span>].view[:] = [1,2,3,4]</div><div class="line">pop.push_extra_global_param_to_device(<span class="stringliteral">&quot;reward&quot;</span>, 4)</div></div><!-- fragment -->  </div> Extra global parameters can also be used to provide additional data to snippets used for variable (see <a class="el" href="../../d4/dc6/sectVariableInitialisation.html">Variable initialisation</a>) or sparse connectivity (see <a class="el" href="../../d5/dd4/sectSparseConnectivityInitialisation.html">Sparse connectivity initialisation</a>) initialisation.  <div class='toggleable_div label_cpp' style='display: none;'> Like standard extra global parameters, GeNN generates additional functions to allocte, free and copy these extra global parameters between host and device:<ul>
<li><code>allocate&lt;egp name&gt;&lt;var name&gt;&lt;neuron or synapse name&gt;</code></li>
<li><code>free&lt;egp name&gt;&lt;var name&gt;&lt;neuron or synapse name&gt;</code></li>
<li><code>push&lt;egp name&gt;&lt;var name&gt;&lt;neuron or synapse name&gt;ToDevice</code></li>
<li><code>pull&lt;egp name&gt;&lt;var name&gt;&lt;neuron or synapse name&gt;FromDevice</code>  </div>  <div class='toggleable_div label_python' style='display: none;'> These extra global parameters must be initialised before <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a662cf82b5390a03b117581a47b0ae147" title="import the model as shared library and initialize it ">pygenn.genn_model.GeNNModel.load</a> is called: <div class="fragment"><div class="line">pop.vars[<span class="stringliteral">&quot;g&quot;</span>].set_extra_global_init_param(<span class="stringliteral">&quot;kernel&quot;</span>, [1, 2, 3, 4])</div></div><!-- fragment -->  </div> </li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="floatPrecision"></a>
Floating point precision</h1>
<p>Double precision floating point numbers are supported by devices with compute capability 1.3 or higher. If you have an older GPU, you need to use single precision floating point in your models and simulation. Furthermore, GPUs are designed to work better with single precision while double precision is the standard for CPUs. This difference should be kept in mind while comparing performance.</p>
<p>Typically, variables in GeNN models are defined using the <code>scalar</code> type. This type is substituted with "float" or "double" during code generation, according to the model precision. This is specified <span class='toggleable_div label_cpp' style='display: none;'>with <a class="el" href="../../da/dfd/classModelSpec.html#a7548f1bf634884c051e4fbac3cf6212c" title="Set numerical precision for floating point. ">ModelSpec::setPrecision()</a> &ndash; either <code>GENN_FLOAT</code> or <code>GENN_DOUBLE</code>. <code>GENN_FLOAT</code> is the default value</span><span class='toggleable_div label_python' style='display: none;'>with the first parameter to <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a707a6343ef7de18dec66b562d3ab19af" title="Init GeNNModel. ">pygenn.genn_model.GeNNModel.__init__</a> as a string e.g. "float"</span>.</p>
<p>There may be ambiguities in arithmetic operations using explicit numbers. Standard C compilers presume that any number defined as "X" is an integer and any number defined as "X.Y" is a double. Make sure to use the same precision in your operations in order to avoid performance loss.</p>
<h1><a class="anchor" id="ListOfVariables"></a>
Working with variables in GeNN</h1>
<h2><a class="anchor" id="modelVars"></a>
Model variables</h2>
<p>User-defined model variables originate from classes derived off the <a class="el" href="../../d7/dad/classNeuronModels_1_1Base.html" title="Base class for all neuron models. ">NeuronModels::Base</a>, <a class="el" href="../../d2/d05/classWeightUpdateModels_1_1Base.html" title="Base class for all weight update models. ">WeightUpdateModels::Base</a> or <a class="el" href="../../d1/d3a/classPostsynapticModels_1_1Base.html" title="Base class for all postsynaptic models. ">PostsynapticModels::Base</a> classes. The name of model variable is defined in the model type, i.e. with a statement such as  <div class='toggleable_div label_cpp' style='display: none;'></p><div class="fragment"><div class="line"><a class="code" href="../../d4/d13/models_8h.html#a3025b9fc844fccdf8cc2b51ef4a6e0aa">SET_VARS</a>({{<span class="stringliteral">&quot;V&quot;</span>, <span class="stringliteral">&quot;scalar&quot;</span>}});</div></div><!-- fragment --><p> </div>  <div class='toggleable_div label_python' style='display: none;'></p><div class="fragment"><div class="line">var_name_types=[(<span class="stringliteral">&quot;V&quot;</span>, <span class="stringliteral">&quot;scalar&quot;</span>)]</div></div><!-- fragment --><p> </div>  <div class='toggleable_div label_cpp' style='display: none;'> When a neuron or synapse population using this model is added to the model, the full GeNN name of the variable will be obtained by concatenating the variable name with the name of the population. For example if we add a population called <code>Pop</code> using a model which contains our <code>V</code> variable, a variable <code>VPop</code> of type <code>scalar*</code> will be available in the global namespace of the simulation program. GeNN will pre-allocate this C array to the correct size of elements corresponding to the size of the neuron population. Users can otherwise manipulate these variable arrays as they wish.  </div>  <div class='toggleable_div label_python' style='display: none;'> When a neuron or synapse population using this model is added to the model, it is built (with <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a481795d2e7a45410799786a1c5122834" title="Finalize and build a GeNN model. ">pygenn.genn_model.GeNNModel.build</a>) and loaded (with <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a662cf82b5390a03b117581a47b0ae147" title="import the model as shared library and initialize it ">pygenn.genn_model.GeNNModel.load</a>), it is available to Python code via a numpy memory view into the host memory: </p><div class="fragment"><div class="line">pop.vars[<span class="stringliteral">&quot;V&quot;</span>].view[:] = 1.2</div></div><!-- fragment --><p>  </div> For convenience, GeNN provides functions to copy each state variable from the device into host memory and vice versa e.g. <span class='toggleable_div label_cpp' style='display: none;'><code>pullVPopFromDevice()</code> and <code>pushVPoptoDevice()</code> </span><span class='toggleable_div label_python' style='display: none;'><a class="el" href="../../d1/db3/classpygenn_1_1genn__groups_1_1Group.html#abcec12cb1265ccbf88598a3d6865fafd" title="Wrapper around GeNNModel.pull_var_from_device. ">pygenn.genn_groups.Group.pull_var_from_device</a> and <a class="el" href="../../d1/db3/classpygenn_1_1genn__groups_1_1Group.html#a70d941612e5dc677054034c781a544da" title="Wrapper around GeNNModel.push_var_to_device. ">pygenn.genn_groups.Group.push_var_to_device</a></span>. Alternatively, all state variables associated with a population can be copied using a single call E.g.  <div class='toggleable_div label_cpp' style='display: none;'></p><div class="fragment"><div class="line">pullPopStateFromDevice();</div></div><!-- fragment --><p> </div>  <div class='toggleable_div label_python' style='display: none;'></p><div class="fragment"><div class="line">pop.pull_state_from_device()</div></div><!-- fragment --><p> </div> These conventions also apply to the the variables of postsynaptic and weight update models.  <div class='toggleable_div label_cpp' style='display: none;'> </p><dl class="section note"><dt>Note</dt><dd>Be aware that the above naming conventions do assume that variables from the weightupdate models and the postSynModels that are used together in a synapse population are unique. If both the weightupdate model and the postSynModel have a variable of the same name, the behaviour is undefined.  </div></dd></dl>
<h2><a class="anchor" id="predefinedVars"></a>
Built-in Variables in GeNN</h2>
<p>GeNN has no explicitly hard-coded synapse and neuron variables. Users are free to name the variable of their models as they want. However, there are some reserved variables that are used for intermediary calculations and communication between different parts of the generated code. They can be used in the user defined code but no other variables should be defined with these names.</p>
<ul>
<li><code>DT</code> : Time step (typically in ms) for simulation; Neuron integration can be done in multiple sub-steps inside the neuron model for numerical stability (see Traub-Miles and Izhikevich neuron model variations in <a class="el" href="../../de/ded/sectNeuronModels.html">Neuron models</a>).</li>
<li><code>inSyn:</code> This is an intermediary synapse variable which contains the summed input into a postsynaptic neuron (originating from the $(addToInSyn, X) or $(addToInSynDelay, X, Y) functions of the weight update model used by incoming synapses) .</li>
<li><code>Isyn</code> : This is a local variable which contains the (summed) input current to a neuron. It is typically the sum of any explicit current input and all synaptic inputs. The way its value is calculated during the update of the postsynaptic neuron is defined by the code provided in the postsynaptic model. For example, the standard <a class="el" href="../../d5/d27/classPostsynapticModels_1_1ExpCond.html" title="Exponential decay with synaptic input treated as a conductance value. ">PostsynapticModels::ExpCond</a> postsynaptic model defines  <div class='toggleable_div label_cpp' style='display: none;'><div class="fragment"><div class="line"><a class="code" href="../../d8/d47/postsynapticModels_8h.html#a41d7141aeae91e2840c2629106b6a3b1">SET_APPLY_INPUT_CODE</a>(<span class="stringliteral">&quot;$(Isyn) += $(inSyn)*($(E)-$(V));&quot;</span>);</div></div><!-- fragment --> </div>  <div class='toggleable_div label_python' style='display: none;'><div class="fragment"><div class="line">apply_input_code=<span class="stringliteral">&quot;$(Isyn) += $(inSyn)*($(E)-$(V));&quot;</span></div></div><!-- fragment --> </div> which implements a conductance based synapse in which the postsynaptic current is given by <img class="formulaInl" alt="$I_{\rm syn}= g*s*(V_{\rm rev}-V_{\rm post})$" src="../../form_5.png"/>. The value of $(Isyn) resulting from the apply input code can then be used in neuron sim code like so: <div class="fragment"><div class="line">$(V)+= (-$(V)+$(Isyn))*DT </div></div><!-- fragment --></li>
<li><code>sT</code> : This is a neuron variable containing the spike time of each neuron and is automatically generated for pre and postsynaptic neuron groups if they are connected using a synapse population with a weight update model that has <span class='toggleable_div label_cpp' style='display: none;'><a class="el" href="../../dc/dab/weightUpdateModels_8h.html#ad06378df00a5d9ffe4068ba2c01b09ab">SET_NEEDS_PRE_SPIKE_TIME(true)</a> or <a class="el" href="../../dc/dab/weightUpdateModels_8h.html#a4f3e008922887cba8cfafc0fb0e53965">SET_NEEDS_POST_SPIKE_TIME(true)</a></span><span class='toggleable_div label_python' style='display: none;'><code>is_pre_spike_time_required=True</code> or <code>is_post_spike_time_required=True</code> </span> set.</li>
<li><code>prev_sT:</code> This is a neuron variable containing the <em>previous</em> spike time of each neuron and is automatically generated for pre and postsynaptic neuron groups if they are connected using a synapse population with a weight update model that has <span class='toggleable_div label_cpp' style='display: none;'><a class="el" href="../../dc/dab/weightUpdateModels_8h.html#abe55020d64a8ec4a28679655ef8c4eb1">SET_NEEDS_PREV_PRE_SPIKE_TIME(true)</a> or <a class="el" href="../../dc/dab/weightUpdateModels_8h.html#a689cf929f3384f6ac4e47d3cfe89182e">SET_NEEDS_PREV_POST_SPIKE_TIME(true)</a></span><span class='toggleable_div label_python' style='display: none;'><code>is_prev_pre_spike_time_required=True</code> or <code>is_prev_post_spike_time_required=True</code> </span> set.</li>
</ul>
<p>In addition to these variables, neuron variables can be referred to in the synapse models by calling $(&lt;neuronVarName&gt;_pre) for the presynaptic neuron population, and $(&lt;neuronVarName&gt;_post) for the postsynaptic population. For example, $(sT_pre), $(sT_post), $(V_pre), etc.</p>
<h1><a class="anchor" id="spikeRecording"></a>
Spike Recording</h1>
<p>Especially in models simulated with small timesteps, very few spikes may be emitted every timestep, making calling <span class='toggleable_div label_cpp' style='display: none;'><code>pull&lt;neuron name&gt;CurrentSpikesFromDevice()</code> or <code>pull&lt;neuron name&gt;SpikesFromDevice()</code> </span><span class='toggleable_div label_python' style='display: none;'> <a class="el" href="../../dc/dc9/classpygenn_1_1genn__groups_1_1NeuronGroup.html#a32debd8385a75f67cbf220a02eb39abb" title="Wrapper around GeNNModel.pull_current_spikes_from_device. ">pygenn.genn_groups.NeuronGroup.pull_current_spikes_from_device</a> </span> every timestep very inefficient. Instead, the spike recording system allows spikes and spike-like events emitted over a number of timesteps to be collected in GPU memory before transferring to the host. Spike recording can be enabled on chosen neuron groups with the <span class='toggleable_div label_cpp' style='display: none;'><code><a class="el" href="../../d7/d3b/classNeuronGroup.html#a34da6fbc527096cc929cc17aa7b2ee86" title="Enables and disable spike recording for this population. ">NeuronGroup::setSpikeRecordingEnabled</a></code> and <code><a class="el" href="../../d7/d3b/classNeuronGroup.html#a3bb72f69aacc6d2ad3801d8975111847" title="Enables and disable spike event recording for this population. ">NeuronGroup::setSpikeEventRecordingEnabled</a></code> methods </span><span class='toggleable_div label_python' style='display: none;'><a class="el" href="../../dc/dc9/classpygenn_1_1genn__groups_1_1NeuronGroup.html#a040c63d3c2e9d9227ceec3644609d2d5">pygenn.genn_groups.NeuronGroup.spike_recording_enabled</a> property</span>. Remaining GPU memory can then be allocated at runtime for spike recording by <span class='toggleable_div label_cpp' style='display: none;'>calling <code>allocateRecordingBuffers(&lt;number of timesteps&gt;)</code> from user code</span><span class='toggleable_div label_python' style='display: none;'>using the <code>num_recording_timesteps</code> keyword argument to <a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a662cf82b5390a03b117581a47b0ae147" title="import the model as shared library and initialize it ">pygenn.genn_model.GeNNModel.load</a></span>. The data structures can then be copied from the GPU to the host using the <span class='toggleable_div label_cpp' style='display: none;'><code>pullRecordingBuffersFromDevice()</code> function </span><span class='toggleable_div label_python' style='display: none;'><a class="el" href="../../db/d57/classpygenn_1_1genn__model_1_1GeNNModel.html#a9c5fc9394f573e6e464fa3a6add748f0" title="Pull recording buffers from device. ">pygenn.genn_model.GeNNModel.pull_recording_buffers_from_device</a> method</span> and the spikes emitted by a population can be accessed <span class='toggleable_div label_cpp' style='display: none;'>in bitmask form via the <code>recordSpk&lt;neuron name&gt;</code> variable</span><span class='toggleable_div label_python' style='display: none;'>via the <a class="el" href="../../dc/dc9/classpygenn_1_1genn__groups_1_1NeuronGroup.html#a983894b5a8c49e837820ea7065d17e10">pygenn.genn_groups.NeuronGroup.spike_recording_data</a> property</span>  <span class='toggleable_div label_cpp' style='display: none;'>Similarly, spike-like events emitted by a population can be accessed via the <code>recordSpkEvent&lt;neuron name&gt;</code> variable. To make decoding the bitmask data structure easier, the <code><a class="el" href="../../d8/d86/spikeRecorder_8h.html#a7a75a9dcce1dbfc4f42fe6180a3c6a6d" title="Writes spikes recorded using GeNN&#39;s spike timing sytem directly to binary file. ">writeBinarySpikeRecording</a></code> and <code><a class="el" href="../../d8/d86/spikeRecorder_8h.html#af6739ef4f0b3b6300bf68f4c8f27e456">writeTextSpikeRecording</a></code> helper functions can be used by including <a class="el" href="../../d8/d86/spikeRecorder_8h.html">spikeRecorder.h</a> in the user code.</span></p>
<p> <div class='toggleable_div label_cpp' style='display: none;'> </p>
<h1><a class="anchor" id="Debugging"></a>
Debugging suggestions</h1>
<p>In Linux, users can call <code>cuda-gdb</code> to debug on the GPU. Example projects in the <code>userproject</code> directory come with a flag to enable debugging (&ndash;debug). genn-buildmodel.sh has a debug flag (-d) to generate debugging data. If you are executing a project with debugging on, the code will be compiled with -g -G flags. In CPU mode the executable will be run in gdb, and in GPU mode it will be run in cuda-gdb in tui mode.</p>
<dl class="section note"><dt>Note</dt><dd>Do not forget to switch debugging flags -g and -G off after debugging is complete as they may negatively affect performance.</dd></dl>
<p>On Mac, some versions of <code>clang</code> aren't supported by the CUDA toolkit. This is a recurring problem on Fedora as well, where CUDA doesn't keep up with GCC releases. You can either hack the CUDA header which checks compiler versions - <code>cuda/include/host_config.h</code> - or just use an older XCode version (6.4 works fine).</p>
<p>On Windows models can also be debugged and developed by opening the sln file used to build the model in Visual Studio. From here files can be added to the project, build settings can be adjusted and the full suite of Visual Studio debugging and profiling tools can be used. </p><dl class="section note"><dt>Note</dt><dd>When opening the models in the <code>userproject</code> directory in Visual Studio, right-click on the project in the solution explorer, select 'Properties'. Then, making sure the desired configuration is selected, navigate to 'Debugging' under 'Configuration Properties', set the 'Working Directory' to '..' and the 'Command Arguments' to match those passed to genn-buildmodel e.g. 'outdir' to use an output directory called outdir.  </div> <hr/>
 <a class="el" href="../../df/d0b/Tutorial2_Python.html">Previous</a> | <a class="el" href="../../d0/da6/UserGuide.html">Top</a> | <a class="el" href="../../dd/d51/Credits.html">Next</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Dec 18 2020 12:54:00 for GeNN by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
<script type="text/javascript">
//<![CDATA[
addLanguageToggleButtons();
//]]>
</script>
</body>
</html>
